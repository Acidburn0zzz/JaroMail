#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.



###################
# Jaro Brother DB
create_addressbook() {
    { test -r $WORKDIR/addressbook } && {
	error "Addressbook already exists: $WORKDIR/addressbook"
	return 1
    }
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook
CREATE TABLE whitelist
(
  email   text collate nocase,
  name    text collate nocase unique,
  hits    int
);
CREATE TABLE blacklist
(
  email   text collate nocase,
  name    text collate nocase unique,
  hits    int
);
EOF
    { test $? != 0 } && {
	error "Error creating addressbook database."
	return 1 }
    # make sure is private
    chmod 600 $WORKDIR/addressbook
    return 0
}
insert_address() {
    func "insert address: $1, $2"
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook 2> /dev/null
INSERT INTO $list (email, name)
VALUES ("${1}", "${2}");
EOF
    { test $? != 0 } && {
	func "address already present in $list"
	return 1
    }
    return $0
}
update_name() {
    func "update address: $1, $2"
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook 2> /dev/null
UPDATE $list SET name="${2}" WHERE email LIKE "${1}";
EOF
    { test $? != 0 } && {
	func "address not found or error occurred" }
}    
remove_address() {
    func "remove address <$1> from $list"
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook
DELETE FROM $list
WHERE email LIKE "${1}";
EOF
    { test $? != 0 } && {
	func "address not found or error occurred" }
}
search_name() {
	cat <<EOF | ${SQL} -column -batch $WORKDIR/addressbook
.width 64 128
SELECT * FROM $list
WHERE name LIKE "%${1}%";
EOF
}
search_email() {
	cat <<EOF | ${SQL} -column -batch $WORKDIR/addressbook
SELECT rowid FROM $list
WHERE email IS "${1}";
EOF
	return $?
}
address() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    act "Searching for \"${PARAM[1]}\" in $list"
    { test "$OS" = "MAC" } && {
	matches=`$WORKDIR/bin/ABQuery ${PARAM[1]}`
    }
    matches="${matches}\n`search_name ${PARAM[1]}`"

    # mutt query requires something like this
    print "jaro: $((`print $matches | wc -l` -1)) matches"
    print "$matches" | awk '
{ printf "%s\t", $1
  for(i=2;i<=NF;i++) {
    sub("<","",$i)
    sub(">","",$i)
    if($i!=$1) printf "%s ", $i
  }
  printf "\n" }'
}
query() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    if [ -z ${PARAM[1]} ]; then
	email="`${WORKDIR}/bin/fetchaddr -a| awk '{print $1}'`"
    else
	email="`${WORKDIR}/bin/fetchaddr -x ${PARAM[1]} -a| awk '{print $1}'`"
    fi
    exitcode=1
    lookup="`search_email ${email}`"
    { test "$lookup" != "" } && { exitcode=0 }
    act "Email <$email> found in $list with id $lookup"
}

learn() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    tmp=$TMPDIR/learn.$datestamp.$RANDOM
    from="`tee -i $tmp | formail -xFrom: | sed -e 's/\"//g'`"
    if [ -z ${PARAM[1]} ]; then
	email="`cat $tmp | ${WORKDIR}/bin/fetchaddr| awk '{print $1}'`"
    else
	email="`cat $tmp | ${WORKDIR}/bin/fetchaddr -x ${PARAM[1]}| awk '{print $1}'`"
    fi
    ${=rm} $tmp &
    insert_address "$email" "$from"
}

forget() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    act "Expecting mail from stdin pipe"
    if [ -z ${PARAM[1]} ]; then
	email="`${WORKDIR}/bin/fetchaddr| awk '{print $1}'`"
    else
	email="`${WORKDIR}/bin/fetchaddr -x ${PARAM[1]}| awk '{print $1}'`"
    fi
    remove_address "${email}"
}
list_addresses() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    { test ${PARAM[1]} } && { list=${PARAM[1]} }

    act "Listing all contents for $list"
    cat <<EOF | ${SQL} -column -header -batch $WORKDIR/addressbook
.width 32 40
SELECT * FROM $list;
EOF
}


# import addresbook email from VCard
import_vcard() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private


    { test -r ${PARAM[1]} } || {
	error "File not found: import ${PARAM[1]}"
	return 1
    }

    vcard=${PARAM[1]}
    head -n1 $vcard | grep '^BEGIN:VCARD' > /dev/null

    { test $? = 0 } || {
	error "File to import is not a VCard: $vcard"
	return 1
    }

    notice "Import in addressbook VCard ${vcard}"
    tmp=$TMPDIR/import.$datestamp.$RANDOM

    # parse the vcard and print a simple name and email list
    # each value on a single line, entry tuples followed by a #
    # we skip entries that don't have an email
    cat ${vcard} | awk '
BEGIN { newcard=0; c=0; name=""; email=""; }
/^BEGIN:VCARD/ { newcard=1 }
/^FN:/ { if(newcard = 1) name=$0 }
/^EMAIL/ { if(newcard = 1) email=$0 }
/^END:VCARD/ {
  if(newcard = 1) {
    newcard=0
    if(email != "") {
      c+=1
      print name
      print email
      print "# " c 
    }
    email=""
    next
  }
}
' | cut -d: -f2  > $tmp

    # now parse the temporary list of name and emails
    # made of name, email and a hash for each, newline separated
    addresses=`cat $tmp`
    ${=rm} $tmp

    newa=1; _name=""; _email=""
    for a in ${(f)addresses}; do
	{ test "${a[1]}" = "#" } && {
	    newa=1; # its the end of the entry
	    # check if we have this email already
	    foundemail=`search_email "${_email}"`
	    { test "$foundemail" = "" } && {
		insert_address "${_email}" "${_name}"
		act "${a} ${_name} <${_email}>"
	    }

	    continue }
	{ test $newa -eq 1 } && {
	    # (V) makes special chars visible, we need to remove them..
	    _name=`echo ${(V)a} | cut -d^ -f1`; newa=0; continue }
	{ test $newa -eq 0 } && { _email=`echo ${(V)a} | cut -d^ -f1` }
    done
    notice "Done importing addresses"
}

# export addressbook to vcard
export_vcard() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    act "Export addressbook into vCard $WORKDIR/addressbook.vcf"
    tmp=$TMPDIR/export.$datestamp.$RANDOM

    cat <<EOF | ${SQL} -column -header -batch $WORKDIR/addressbook \
	| grep -v '^email' > $tmp
.width 40 100
.mode list
.separator '|'
SELECT email, name FROM $list;
EOF

    addresses=`cat $tmp`
    ${=rm} $tmp

    rm -f $WORKDIR/addressbook.vcf
    touch $WORKDIR/addressbook.vcf
    for a in ${(f)addresses}; do
	_email=`echo $a | cut -d'|' -f1`
	# remove from name all what is an email between brackets
	# crop (trim) all beginning and ending whitespaces from name
	_name=`echo $a | cut -d'|' -f2 | sed 's/<.*>//' | sed 's/^[ \t]*//;s/[ \t]*$//'`
	{ test "${_email}" != "" } && {
	    cat <<EOF >> $WORKDIR/addressbook.vcf
BEGIN:VCARD
VERSION:3.0
FN:${_name}
EMAIL;TYPE=HOME:${_email// /}
END:VCARD
EOF
	}
    done

}

export_abook() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    chmod 600 $WORKDIR/addressbook # make sure is private

    if [ -z ${PARAM[1]} ]; then	list=whitelist
    else list=${PARAM[1]}; fi

    act "Editing addressbook $list"
    tmp=$TMPDIR/abook.$datestamp.$RANDOM


    cat <<EOF | ${SQL} -column -header -batch $WORKDIR/addressbook \
	| grep -v '^email' > $tmp
.width 40 100
.mode list
.separator '|'
SELECT email, name FROM $list;
EOF

    addresses=`cat $tmp`
    ${=rm} $tmp

    rm -f $WORKDIR/addressbook.abook
    cat <<EOF > $WORKDIR/addressbook.abook
# abook addressbook file

[format]
program=jaromail
version=1.0

EOF
    c=0
    for a in ${(f)addresses}; do
	_email=`echo $a | cut -d'|' -f1`
	# remove from name all what is an email between brackets
	# crop (trim) all beginning and ending whitespaces from name
	_name=`echo $a | cut -d'|' -f2 | sed 's/<.*>//' | sed 's/^[ \t]*//;s/[ \t]*$//'`
	{ test "${_email}" != "" } && {
	    cat <<EOF >> $WORKDIR/addressbook.abook
[${c}]
name=${_name}
email=${_email}

EOF
	    c=$(( $c + 1 ))
	}
    done
    abook --datafile $WORKDIR/addressbook.abook

    tmp=$TMPDIR/abook.$datestamp.$RANDOM
    
    abook --convert --infile $WORKDIR/addressbook.abook \
	--outformat spruce | awk '
BEGIN { c=0; name=""; email=""; }
/^#/ { if(email != "") {
          c+=1
          print name
          print email
          print "# " c
       }
       email=""
       next
     }
/^Name:/ { name=$0 }
/^Email:/ { email=$0 }
' > $tmp
    addresses=`cat $tmp`
    ${=rm} $tmp

    # move addressbook to old
    act "Updating the addressbook database"
    cat <<EOF > $tmp
DROP TABLE $list;
CREATE TABLE $list
(
  email   text collate nocase,
  name    text collate nocase unique,
  hits    int
);

EOF

    newa=1; _name=""; _email=""
    for a in ${(f)addresses}; do

	{ test "${a[1]}" = "#" } && {
	    newa=1; #its the end of the entry
	    print "INSERT INTO $list (email, name) VALUES (\"${_email}\", \"${_name}\");" >> $tmp
	    continue }

	{ test $newa -eq 1 } && {
	    _name=`echo ${a} | cut -d: -f2`; newa=0; continue }
	{ test $newa -eq 0 } && { _email=`echo ${a// /} | cut -d: -f2` }

    done
    func "Inserting the updated addressbook"
    cat $tmp | ${SQL} -batch $WORKDIR/addressbook 2> /dev/null
    ${=rm} $tmp
    notice "Addressbook updated"
}
    
###################
