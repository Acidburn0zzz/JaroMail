#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

switch_identity() {
    if [ "$name" != "" ]; then
	act "switch to identity: $name <$login>"
	rm -f $MUTTDIR/identity
	cat <<EOF > $MUTTDIR/identity
set hostname = $host
set realname = "$name"
set from = "$name <$login>"
EOF
    else
	error "No identity found, left blank."
	touch $MUTTDIR/identity
    fi
}



# arg 1 : account type, es: imap or smtp
# -a defines which account name other than 'default'
read_account() {
    typeset -al all
    type=$1
    # find the file
    func "read_account looking for \"$account\""
    for a in `find $WORKDIR/Accounts -name "$type.$account*"`; do
	func "found account: $a"
	all+=($a)
    done
    if [ ${#all} = 0 ]; then
	error "No $type account found: $account"
	act "Refine your argument using '-a type.account'"
	act "For instance adding to the commandline: -a imap.default"
	act "Available accounts (excluding symbolic links, omit final .txt):"
	for a in `find $WORKDIR/Accounts -type f | grep -v README | sed 's/.txt//'`; do
	    act -n "`basename $a`\t :: "
	    awk '
/^name/ { for(i=2;i<=NF;i++) printf "%s ", $i }
/^email/ { printf "<%s>", $2 }
/^host/ { printf " on %s", $2 }
{next}' $a.txt
	    echo " (`basename $a | cut -d. -f1`)"
	done
	return 1
    elif [ ${#all} != 1 ]; then
	error "Too many $type accounts named $account"
	act -n ""
	for i in ${=all}; do echo -n "`basename ${i}` "; done
	echo; error "Refine your account keyword using -a option"
	return 1
    fi

    acct=${all[1]}
    type=`basename $acct | cut -d. -f1`

    case $type in
	imap|smtp)

	    lock $acct
	    ttmp=`cat $acct | awk '
    /^#/ { next }
    /^name/ { printf "name=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^email/ { printf "email=\"%s\";", $2 }
    /^host/ { printf "host=\"%s\";", $2 }
    /^login/ { printf "login=\"%s\";", $2 }
    /^transport/ { printf "transport=\"%s\";", $2 }
    /^port/ { printf "port=\"%s\";", $2 }
    /^password/ { printf "password=\"%s\";", $2 }
    /^auth/ { printf "auth=\"%s\";", $2 }
    /^cert/ { printf "cert=\"%s\";", $2 }
    /^options/ { printf "accountopt=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^folders/ { printf "folders=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    '`
	    unlock $acct

	    eval "$ttmp"
	    # check required fields
	    { test -z $host }  && { error "Field missing in account $acct: host"; return 1 }

	    # fill in defaults
	    { test -z $name }       && { name="$type" }
	    { test -z $login }      && { login="$email" } # usually email and login are the same
	    { test -z $email }      && { email="$login" } # so if one is specified, deduce the other
	    { test -z $transport }  && { transport=plain }
	    { test -z $port }       && { port=143 }
	    { test -z $auth }       && { auth=plain }
	    { test -z $cert }       && { cert=ignore }
	    { test -z $accountopt } && { accountopt=keep }
	    # cert and password can be missing

	    func "type: $type"
	    func "name: $name"
	    func "email: $email"
	    func "host: $host"
	    func "login: $login"
	    func "trans: $transport"
	    func "port: $port"
	    func "cert: $cert"
	    func "auth: $auth"
	    func "options: $accountopt"
	    func "folders: $folders"
	    ;;
	*)
	    error "Account type \"$type\" not recognized."
	    return 1
	    ;;
    esac
    return 0
}


update() {
    notice "Updating all configurations and filters"
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...

    # debug configuration
    func "MAILDIRS:    $MAILDIRS"
    func "WORKDIR:     $WORKDIR"
    func "MUTTDIR:     $MUTTDIR"
    func "PROCMAILDIR: $PROCMAILDIR"

    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    maildirmake $MAILDIRS/ml.unsorted
    ${=mkdir} $MAILDIRS/outbox

    ######
    # MUTT
    ${=mkdir} $MUTTDIR
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = $MAILDIRS
set spoolfile = $MAILDIRS/known/
set record = $MAILDIRS/sent/
set postponed= $MAILDIRS/postponed/
set tmpdir = $WORKDIR/cache
set sendmail = "$WORKDIR/bin/jaro queue"
set header_cache= $WORKDIR/cache
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro edit"
set mailcap_path = "$WORKDIR/.mutt/mailcap:$WORKDIR/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q addr '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn from:<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q forget from:<enter>" "remove sender from whitelist
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn from:<enter>" "add sender to blacklist"
macro index,pager Z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q forget from:<enter>" "remove sender from blacklist

# mailboxes in order of priority
source $MUTTDIR/mboxes

# specific configuration files
source $MUTTDIR/crypto
source $MUTTDIR/general
source $MUTTDIR/formats
source $MUTTDIR/keybindings
source $MUTTDIR/identity
source $MUTTDIR/password
source $MUTTDIR/colors
source $WORKDIR/Mutt.txt
## end of Jaro Mail generated muttrc
####################################

EOF

   # making sure we have the minimum mailcap necessary
wwwtext=w3m
{ which lynx > /dev/null } && { wwwtext=lynx }
{ which elinks > /dev/null } && { wwwtext=elinks }
cat <<EOF > $MUTTDIR/mailcap
text/html; ${wwwtext} -dump %s; nametemplate=%s.html; copiousoutput
application/*; a=$WORKDIR/tmp/attach-$RANDOM$RANDOM && cp %s \$a && jaro open \$a
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    # this one is empty and sources files in temp when necessary
    touch $MUTTDIR/password

    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    echo -n "mailboxes +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_account imap

    switch_identity

    ##########
    # PROCMAIL
    act "generating procmail filters"
    ${=mkdir} $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by Jaro Mail
MAILDIR=$MAILDIRS
JARO=$WORKDIR/bin/jaro
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=$WORKDIR/log/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = $PROCMAILDIR
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
PF_RECURSE = yes

# blacklist filters
:0 w:
* ? \$JARO -l blacklist -q query from:
zz.blacklist/

# filters generated from Filters.txt
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    echo "# filters generated from Filters.txt" >> $PROCMAILDIR/rc

    for f in `cat $WORKDIR/Filters.txt | awk '/^#/ {next} /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		func "messages to <${address}> in folder: ${destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		func "messages from <${address}> in folder: {$destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	echo  " \\" >> $MUTTDIR/mboxes
	echo -n " +${destination} " >> $MUTTDIR/mboxes
    done

    # if the sender is known (ldbd recognizes it) then put mail in high priority 'known'
    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# whitelisting filters
:0 w:
* ? \$JARO -l whitelist -q query from:
known/


EOF

    #######
cat <<EOF >> $PROCMAILDIR/rc
# filters generated from Accounts
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF
    for f in `cat $WORKDIR/Accounts/* | awk '/^email/ { print $2 }'`; do
	echo "ADDR=${f}\tDEST=priv/\tINCLUDERC=\$PMSRC/pf-chkto.rc"  >> $PROCMAILDIR/rc
	func "private account: <${f}>"
    done

    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }

# if its an unknown mailinglist, save it into ml.unsorted
:0
* ^(List-Id|X-(Mailing-)?List):
ml.unsorted/

EOF

    # MUTT (generate mailboxes priority this parser)
    echo " \\" >> $MUTTDIR/mboxes
    echo " +ml.unsorted +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes
    rm -f $TMPDIR/mboxes

    # conclude
    cat <<EOF >> $PROCMAILDIR/rc

# if got here, go to unsorted
:0:
\$DEFAULT

#
# End of generated procmail rc
#
EOF
    return 0
} # end of update()

