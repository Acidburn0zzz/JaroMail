#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

update() {
    notice "Updating all configurations and filters"
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...

    # debug configuration
    func "MAILDIRS:    $MAILDIRS"
    func "WORKDIR:     $WORKDIR"
    func "MUTTDIR:     $MUTTDIR"
    func "PROCMAILDIR: $PROCMAILDIR"

    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    maildirmake $MAILDIRS/unsorted.ml
    ${=mkdir} $MAILDIRS/outbox


    ######
    # MUTT
    ${=mkdir} $MUTTDIR
    ${=mkdir} $MUTTDIR/cache
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = '$MAILDIRS'
set spoolfile = '$MAILDIRS/known/'
set record = '$MAILDIRS/sent/'
set postponed= '$MAILDIRS/postponed/'
set tmpdir = '$MUTTDIR/cache'
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= '$MUTTDIR/cache'
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$MUTTDIR/mailcap:$MAILDIRS/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q complete '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn sender<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn all<enter>" "add all addresses in whitelist"
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn sender<enter>" "add sender to blacklist"

# mailboxes in order of priority
source '$MUTTDIR/mboxes'

# specific configuration files
source '$WORKDIR/.mutt/gpg'
source '$WORKDIR/.mutt/crypto'
source '$WORKDIR/.mutt/general'
source '$WORKDIR/.mutt/formats'
source '$WORKDIR/.mutt/keybindings'
source '$WORKDIR/.mutt/colors'
source '$MAILDIRS/Identity'
source '$TMPDIR/muttpass'
EOF

# support user made configuration of mutt
    { test -r $MAILDIRS/Mutt.txt } && {
	print "source '$MAILDIRS/Mutt.txt'" >> $MUTTDIR/rc }

cat <<EOF >> $MUTTDIR/rc
## end of Jaro Mail generated muttrc
####################################

EOF

    # MUTT MAILCAP
    cat <<EOF > $MUTTDIR/mailcap
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    wwwtext=w3m
    if command -v elinks; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; elinks -dump -dump-charset %{charset} -dump-color-mode 0 %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v w3m; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; w3m -I %{charset} -T text/html %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v lynx; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; lynx -dump -assume_charset=%{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    fi
    apptypes=`cat ${WORKDIR}/Applications.txt`
    for t in ${(f)apptypes}; do
	eval `print $t | awk '
    { print "_type=" $1 "; _app=" $2 ";" }'` 
	cat <<EOF >> $MUTTDIR/mailcap
${_type}; a=${WORKDIR}/tmp && f=\`basename %s\` && rm -f \$a/\$f && cp %s \$a/\$f && ${_app} \$a/\$f
EOF
    done
    cat <<EOF >> $MUTTDIR/mailcap
application/*; a=${WORKDIR}/tmp && f=\`basename %s\` && rm -f \$a/\$f && cp %s \$a/\$f && jaro preview \$a/\$f
EOF

    # this one is empty and sources files in temp when necessary
    # touch $TMPDIR/muttpass

    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    print -n "mailboxes +known +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_account imap

    switch_identity

    #######
    # SIEVE
    act "generating sieve filters"
    id=$datestamp.$RANDOM
    sieve=$MAILDIRS/Sieve.txt
    lock $sieve
    rm -f $sieve
    touch $sieve
    chmod 600 $sieve
    cat <<EOF >> $sieve
require "fileinto";

# blacklist
if header :contains "From" [
EOF
    newlock $TMPDIR/blacklist.sieve.$id
    cat <<EOF | ${SQL} -batch ${addressbook} \
	>> $TMPDIR/blacklist.sieve.$id
SELECT email FROM blacklist;
EOF
    typeset -alU blacklist
    for i in `cat $TMPDIR/blacklist.sieve.$id`; do
	blacklist+=($i); done
    unlink $TMPDIR/blacklist.sieve.$id
    c=${#blacklist}
    for b in $blacklist; do
	print -n "\"$b\"" >> $sieve
	c=$(( $c - 1 ))
	{ test $c != 0 } && { print -n "," >> $sieve }
	print >> $sieve
    done

cat <<EOF >> $sieve
]
{ fileinto "zz.blacklist"; stop; }

# bounces
if header :contains "Sender" "mailman-bounce" {
    fileinto "zz.bounces";
    stop;
}

# filters
EOF

# continue later on while we parse filters



    ##########
    # PROCMAIL
    act "generating procmail filters"
    ${=mkdir} $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by Jaro Mail
MAILDIR=$MAILDIRS
JARO=$WORKDIR/bin/jaro
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=\$MAILDIR/logs/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = $PROCMAILDIR
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
PF_RECURSE = yes

# blacklist filters
:0 w:
* ? \$JARO -l blacklist -q isknown
zz.blacklist/

# if its a mailinglist bounce, save it to zz.bounces
:0
* ^Sender: mailman-bounce
zz.bounces/

# filters generated from Filters.txt
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    print "# filters generated from Filters.txt" >> $PROCMAILDIR/rc

    typeset -alU filter_from
    typeset -alU filter_to

    for f in `cat $WORKDIR/Filters.txt | awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		func "messages to <${address}> in folder: ${destination}"
		maildirmake $MAILDIRS/$destination
		filter_to+=($address)
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		func "messages from <${address}> in folder: {$destination}"
		maildirmake $MAILDIRS/$destination
		filter_from+=($address)
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	print  " \\" >> $MUTTDIR/mboxes
	print -n " +${destination} " >> $MUTTDIR/mboxes
    done

    # now do the sieve
    { test ${#filter_to} -gt 0 } && {
	cat <<EOF >> $sieve
# filter to
if header :contains "To" [
EOF
	c=${#filter_to}
	for f in $filter_to; do
	    print -n "\"$f\"" >> $sieve
	    c=$(( $c - 1 ))
	    { test $c != 0 } && { print -n "," >> $sieve }
	    print >> $sieve
	done
	cat <<EOF >> $sieve
]
{ fileinto "filters"; stop; }

EOF
    }

    { test ${#filter_from} -gt 0 } && {
	cat <<EOF >> $sieve
# filter from
if header :contains "From" [
EOF
	c=${#filter_from}
	for f in $filter_from; do
	    print -n "\"$f\"" >> $sieve
	    c=$(( $c - 1 ))
	    { test $c != 0 } && { print -n "," >> $sieve }
	    print >> $sieve
	done
	cat <<EOF >> $sieve
]
{ fileinto "filters"; stop; }

EOF
    }

    ##############################################################
    # if the sender is known (whitelist) then put mail in
    # high priority 'known' (procmail) or INBOX (sieve)



#### SIEVE

func "generating whitelist for sieve filters"
cat <<EOF >> $sieve
# whitelist
if header :contains "From" [
EOF
newlock $TMPDIR/whitelist.sieve.$id
cat <<EOF | ${SQL} -batch ${addressbook} \
    >> $TMPDIR/whitelist.sieve.$id
SELECT email FROM whitelist;
EOF
typeset -alU whitelist
for i in `cat $TMPDIR/whitelist.sieve.$id`; do
    whitelist+=($i); done
unlink $TMPDIR/whitelist.sieve.$id
c=${#whitelist}
for w in $whitelist; do
    print -n "\"$w\"" >> $sieve
    c=$(( $c - 1 ))
    { test $c != 0 } && { print -n "," >> $sieve }
    print >> $sieve
done
cat <<EOF >> $sieve
]
{ fileinto "INBOX"; stop; }

# spam
if header :is "X-Spam-Flag" "YES" {
    fileinto "zz.spam";
    stop;
}

EOF

unlock $sieve

#### PROCMAIL

    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# whitelisting filters
:0 w:
* ? \$JARO -l whitelist -q isknown
known/

# spam filters
:0 w:
* ^X-Spam-Flag: YES
zz.spam/

EOF

    #######
    cat <<EOF >> $PROCMAILDIR/rc
# filters generated from Accounts
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF
    cat <<EOF >> $sieve
# sent to our own address
if header :contains "To" [
EOF
    typeset -alU recv
    for f in `${=find} $WORKDIR/Accounts/ -type f | grep -v 'smtp'`; do
	for addr in `cat $f | awk '
    /^email/ { print $2 }
    /^alias/ { print $2 }
    '`; do func "email $addr in `basename $f`"; recv+=($addr); done
    done
    c=${#recv}
    for rr in ${recv}; do \

	# procmail
	print "ADDR=${rr}\tDEST=priv/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
	>> $PROCMAILDIR/rc

	# sieve
	print -n "\"${rr}\"" >> $sieve
	c=$(( $c - 1 ))
	{ test $c != 0 } && { print -n "," >> $sieve }
	print >> $sieve
	
	act "private account: <${rr}>"
    done

    cat <<EOF >> $sieve
]
{ fileinto "priv"; stop; }

EOF

    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# if its an unknown mailinglist, save it into unsorted.ml
:0
* ^(List-Id|X-(Mailing-)?List):
unsorted.ml/

EOF

    # MUTT (generate mailboxes priority this parser)
    print " \\" >> $MUTTDIR/mboxes
    print " +unsorted.ml +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes
    rm -f $TMPDIR/mboxes

    # conclude procmail
    cat <<EOF >> $PROCMAILDIR/rc

# if got here, go to unsorted
:0:
\$DEFAULT

#
# End of generated procmail rc
#
EOF


    # conclude sieve
cat <<EOF >> $sieve

fileinto "unsorted";
EOF

    return 0
} # end of update()
