#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

update() {
    notice "Updating all configurations and filters"
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...

    # debug configuration
    func "MAILDIRS:    $MAILDIRS"
    func "WORKDIR:     $WORKDIR"
    func "MUTTDIR:     $MUTTDIR"
    func "PROCMAILDIR: $PROCMAILDIR"

    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    maildirmake $MAILDIRS/unsorted.ml
    ${=mkdir} $MAILDIRS/outbox

    ######
    # MUTT
    ${=mkdir} $MUTTDIR
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = $MAILDIRS
set spoolfile = $MAILDIRS/known/
set record = $MAILDIRS/sent/
set postponed= $MAILDIRS/postponed/
set tmpdir = $WORKDIR/cache
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= $WORKDIR/cache
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$WORKDIR/.mutt/mailcap:$WORKDIR/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q addr '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn from:<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q forget from:<enter>" "remove sender from whitelist
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn from:<enter>" "add sender to blacklist"
macro index,pager Z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q forget from:<enter>" "remove sender from blacklist

# mailboxes in order of priority
source $MUTTDIR/mboxes

# specific configuration files
source $MUTTDIR/crypto
source $MUTTDIR/general
source $MUTTDIR/formats
source $MUTTDIR/keybindings
source $MUTTDIR/identity
source $MUTTDIR/password
source $MUTTDIR/colors
source $WORKDIR/Mutt.txt
## end of Jaro Mail generated muttrc
####################################

EOF

   # making sure we have the minimum mailcap necessary
wwwtext=w3m
{ which lynx > /dev/null } && { wwwtext=lynx }
{ which elinks > /dev/null } && { wwwtext=elinks }
cat <<EOF > $MUTTDIR/mailcap
text/html; ${wwwtext} -dump %s; nametemplate=%s.html; copiousoutput
application/*; a=$WORKDIR/tmp/attach-$RANDOM$RANDOM && cp %s \$a && jaro open \$a
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    # this one is empty and sources files in temp when necessary
    touch $MUTTDIR/password

    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    echo -n "mailboxes +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_account imap

    switch_identity

    ##########
    # PROCMAIL
    act "generating procmail filters"
    ${=mkdir} $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by Jaro Mail
MAILDIR=$MAILDIRS
JARO=$WORKDIR/bin/jaro
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=$WORKDIR/log/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = $PROCMAILDIR
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
PF_RECURSE = yes

# blacklist filters
:0 w:
* ? \$JARO -l blacklist -q query from:
zz.blacklist/

# if its a mailinglist bounce, save it to zz.bounces
:0
* ^Sender: mailman-bounce
zz.bounces/

# filters generated from Filters.txt
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    echo "# filters generated from Filters.txt" >> $PROCMAILDIR/rc

    for f in `cat $WORKDIR/Filters.txt | awk '/^#/ {next} /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		func "messages to <${address}> in folder: ${destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		func "messages from <${address}> in folder: {$destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	echo  " \\" >> $MUTTDIR/mboxes
	echo -n " +${destination} " >> $MUTTDIR/mboxes
    done

    # if the sender is known (ldbd recognizes it) then put mail in high priority 'known'
    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# whitelisting filters
:0 w:
* ? \$JARO -l whitelist -q query from:
known/


EOF

    #######
cat <<EOF >> $PROCMAILDIR/rc
# filters generated from Accounts
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF
    for f in `cat $WORKDIR/Accounts/* | awk '/^email/ { print $2 }'`; do
	echo "ADDR=${f}\tDEST=priv/\tINCLUDERC=\$PMSRC/pf-chkto.rc"  >> $PROCMAILDIR/rc
	func "private account: <${f}>"
    done

    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# if its an unknown mailinglist, save it into unsorted.ml
:0
* ^(List-Id|X-(Mailing-)?List):
unsorted.ml/

EOF

    # MUTT (generate mailboxes priority this parser)
    echo " \\" >> $MUTTDIR/mboxes
    echo " +unsorted.ml +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes
    rm -f $TMPDIR/mboxes

    # conclude
    cat <<EOF >> $PROCMAILDIR/rc

# if got here, go to unsorted
:0:
\$DEFAULT

#
# End of generated procmail rc
#
EOF
    return 0
} # end of update()

