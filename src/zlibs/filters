#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2014 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

###################
# Filters workflow:
#
#  1. Check if From in blacklist   -> zz.blacklist
#  2. Check if /Sender.*bounce/    -> zz.bounces
#  3. Check if From Filters match  -> own.setup
#  4. Check if To   Filters match  -> own.setup
#  5. Check if From in whitelist   -> known
#  6. Check if /X-Spam-Flag.*YES/  -> zz.spam
#  7. Check if To own address      -> priv
#  8. All the rest                 -> unsorted
#

# load zsh filter cache arrays
{ test -r $MAILDIRS/cache/filters } && {
    source $MAILDIRS/cache/filters }

init_inbox() {
    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/incoming
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    maildirmake $MAILDIRS/unsorted.ml
    maildirmake $MAILDIRS/remember
    maildirmake $MAILDIRS/outbox

    ${=mkdir} $MAILDIRS/cache
    ${=mkdir} $MAILDIRS/logs
    ${=mkdir} $MAILDIRS/tmp

    return 0
}

# short utility to print only mail headers
hdr() {
    { test -r "$1" } || {
	error "hdr() called on non existing file: $1"
	return 1 }
    awk '{ print $0 }
/^$/ { exit }' "$1"
}

update_filters() {
    { test -r "$MAILDIRS/Filters.txt" } || {
	error "Filters not found in $MAILDIRS/Filters.txt"
	return 1 }

    notice "Updating filters..."

    ff="$MAILDIRS/cache/filters"
    ${=mkdir} "$MAILDIRS/cache"

    { test -r "$ff" } && { rm -f "$ff" }
    newlock "$ff"
    cat <<EOF >> "$ff"
# automatically generated by jaromail
typeset -Al filter_from
typeset -Al filter_to

EOF
    ffilters=`cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`

    # insert filter rules in the cache
    for f in ${(f)ffilters}; do
	header="${f[(ws:;:)1]}"
	regexp="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		cat <<EOF >> "$ff"
filter_to+=("${regexp}" "${destination}")
EOF
		func "from: <${regexp}> -> ${destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    from)
		cat <<EOF >> "$ff"
filter_from+=("${regexp}" "${destination}")
EOF
		func "to: <${regexp}> -> ${destination}"
		maildirmake $MAILDIRS/$destination
		;;

	    *)
		error "invalid filter: $f"
		;;
	esac
    done

    unlock "$ff"
    zcompile "$ff"
    source "$ff"
    return 0
}

filter_maildir() {

    # for safety we bail out in case the final fallback
    # maildir is not existing. unsorted should always
    # be there.
    maildircheck "$MAILDIRS/unsorted"
    { test $? = 0 } || {
	error "Invalid fallback maildir destination, operation aborted."
	func "Returning error to caller."
	return 1; }

    # loads up the filter cache (zsh compiled arrays)
    { test -r "$MAILDIRS/cache/filters" } && {
	source $MAILDIRS/cache/filters
	ownfilters=1 }

    if [ "$1" = "" ]; then
	input="incoming"
    else
	input="$1"
    fi

    maildircheck "$MAILDIRS/$input"
    { test $? = 0 } || {
	error "Invalid maildir to filter: $input"
	return 1; }

    numm=`${=find} "$MAILDIRS/$input" -maxdepth 2 -type f|wc -l`
    mails=`${=find} "$MAILDIRS/$input" -maxdepth 2 -type f`

    { test "$numm" = "0" } && {
	error "Nothing to filter inside maildir $input"
	return 1 }

    notice "Filtering maildir: $input ($numm mails}"
    c=0
    for m in ${(f)mails}; do
	match=0
	c=$(($c + 1))

	list="blacklist"
	hdr "$m" | isknown
	{ test $? = 0 } && {
	    cat "$m" | deliver zz.blacklist
	    { test $? = 0 } && { ${=rm} "$m" }
	    act "$c\t\t/ $numm\t\t->\tzz.blacklist"
	    continue }

	hdr "$m" | awk '/Sender.*bounce/ { exit 1 }'
	{ test $? = 0 } || {
	    act "$c\t\t/ $numm\t\t->\tzz.bounce"
	    cat "$m" | deliver zz.bounces
	    { test $? = 0 } && { ${=rm} "$m" }
	    continue }

	{ test "$ownfilters" = "1" } && {

	    func "processing through own filters"
	    ffrom=`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x From -a`

	    # run all filter regexps on the from: field
	    { test "$ffrom" = "" } || {
		femail="${ffrom[(ws:,:)1]}"
		for exp in ${(k)filter_from}; do
		    if [[ "$femail" =~ "$exp" ]]; then
			act "$c\t\t/ $numm\t\t-> ${filter_from[$exp]}"
			cat "$m" | deliver ${filter_from[$exp]}
			if [ $? = 0 ]; then
			    func "from filter match: $exp"
			    ${=rm} $m
			    match=1
			else
			    error "Error filtering to maildir ${filter_from[$exp]}"
			    error "File: $m"
			fi
		    fi
		done
	    }
	    { test "$match" = "1" } && { continue }

	    ftos=`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x Cc -a | cut -d, -f1`
	    ftos+=`hdr "$m" | ${WORKDIR}/bin/fetchaddr -x To -a | cut -d, -f1`

	    # run all filter regexps on the to: and cc: fields
	    { test "$ftos" = "" } || {
		for ft in ${(f)ftos}; do
		    for exp in ${(k)filter_to}; do
			if [[ "$ft" =~ "$exp" ]]; then
			    act "$c\t\t/ $numm\t\t-> ${filter_to[$exp]}"
			    cat "$m" | deliver ${filter_to[$exp]}
			    if [ $? = 0 ]; then
				func "to filter match: $exp"
				${=rm} "$m"
				match=1
			    else
				error "Error filtering to maildir ${filter_to[$exp]}"
				error "File: $m"
			    fi
			fi
		    done
		done
	    }
	    { test "$match" = "1" } && { continue }

	} # own filters

	list="whitelist"
	hdr "$m" | isknown
	{ test $? = 0 } && { print "hit on whitelist"
	    act "$c\t\t/ $numm\t\t-> known"
	    cat "$m" | deliver known
	    { test $? = 0 } && { ${=rm} "$m" }
	    continue }

	hdr "$m" | awk '/X-Spam-Flag.*YES/ { exit 1 }'
	{ test $? = 0 } || {
	    act "$c\t\t/ $numm\t\t-> zz.spam"
	    cat "$m" | deliver zz.spam
	    { test $? = 0 } && { ${=rm} "$m" }
	    continue }

	# if here then file to unsorted
	act "$c\t\t/ $numm\t\t-> unsorted"
	cat "$m" | deliver unsorted
	{ test $? = 0 } && { ${=rm} "$m" }

    done

    return 0
}

######
# MUTT

update_mutt() {
    act "updating mutt settings"
    func "MUTTDIR:     $MUTTDIR"

    func "binary: $mutt"
    func "pgpewrap: $pgpewrap"
    func "lock: $dotlock"
    ${=mkdir} $MUTTDIR
    ${=mkdir} $MUTTDIR/cache
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = '$MAILDIRS'
set spoolfile = '$MAILDIRS/known/'
set record = '$MAILDIRS/sent/'
set postponed= '$MAILDIRS/postponed/'
set tmpdir = '$MUTTDIR/cache'
set sendmail = "$WORKDIR/bin/jaro -q queue"
set header_cache= '$MUTTDIR/cache'
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro -q edit"
set mailcap_path = "$MUTTDIR/mailcap:$MAILDIRS/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q complete '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn sender<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn all<enter>" "add all addresses in whitelist"
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn sender<enter>" "add sender to blacklist"

# mailboxes in order of priority
source '$MUTTDIR/mboxes'

# specific configuration files
source '$WORKDIR/.mutt/gpg'
source '$WORKDIR/.mutt/crypto'
source '$WORKDIR/.mutt/general'
source '$WORKDIR/.mutt/formats'
source '$WORKDIR/.mutt/keybindings'
source '$WORKDIR/.mutt/colors'
source '$MAILDIRS/Identity'
source '$TMPDIR/muttpass'
EOF

# support user made configuration of mutt
    { test -r "$MAILDIRS/Mutt.txt" } && {
	print "source '$MAILDIRS/Mutt.txt'" >> $MUTTDIR/rc }



#####################
# helper applications
act "configuring helper applications"
cat <<EOF >> "$MUTTDIR/rc"
## end of Jaro Mail generated muttrc
####################################

EOF

    # MUTT MAILCAP
    cat <<EOF > $MUTTDIR/mailcap
text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    wwwtext=w3m
    if command -v elinks > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; elinks -dump -dump-charset %{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v w3m > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; w3m -I %{charset} -T text/html %s; nametemplate=%s.html; copiousoutput
EOF
    elif command -v lynx > /dev/null; then
	cat <<EOF >> $MUTTDIR/mailcap
text/html; lynx -dump -assume_charset=%{charset} %s; nametemplate=%s.html; copiousoutput
EOF
    fi

    { test -r "${MAILDIRS}/Applications.txt" } && {

    apptypes=`cat "${MAILDIRS}/Applications.txt"`
    for t in ${(f)apptypes}; do
	eval `print $t | awk '
    { print "_type=" $1 "; _app=" $2 ";" }'` 
	cat <<EOF >> $MUTTDIR/mailcap
${_type}; a="${TMPDIR}" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && ${_app} "\$a"/"\$f"
EOF
    done
    cat <<EOF >> $MUTTDIR/mailcap
application/*; a="${TMPDIR}" && f=\`basename %s\` && rm -f "\$a"/"\$f" && cp %s "\$a"/"\$f" && jaro preview "\$a"/"\$f"
EOF
    } # Applications.txt


    # this one is empty and sources files in temp when necessary
    # touch $TMPDIR/muttpass

    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    print -n "mailboxes +known +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_account imap

    switch_identity

    for f in `cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $4 }'`; do
	# MUTT (generate mailboxes priority this parser)
	print  " \\" >> $MUTTDIR/mboxes
	print -n " +${f} " >> $MUTTDIR/mboxes
    done
    print " \\" >> $MUTTDIR/mboxes
    print " +unsorted.ml +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes

}

update_sieve() {


    #######
    # SIEVE
    act "generating sieve filter rules"
    id=$datestamp.$RANDOM
    newlock "$MAILDIRS/Filters.sieve"
    rm -f "$MAILDIRS/Filters.sieve"
    touch "$MAILDIRS/Filters.sieve"
    chmod 600 "$MAILDIRS/Filters.sieve"
    cat <<EOF >> "$MAILDIRS/Filters.sieve"
require "fileinto";

# blacklist
if header :contains "From" [
EOF
    newlock "$TMPDIR/blacklist.sieve.$id"
    cat <<EOF | ${SQL} -batch ${addressbook} \
	>> "$TMPDIR/blacklist.sieve.$id"
SELECT email FROM blacklist;
EOF
    typeset -alU blacklist
    for i in `cat "$TMPDIR/blacklist.sieve.$id"`; do
	blacklist+=("$i"); done
    unlink "$TMPDIR/blacklist.sieve.$id"
    c=${#blacklist}
    for b in $blacklist; do
	print -n "\"$b\"" >> "$MAILDIRS/Filters.sieve"
	c=$(( $c - 1 ))
	{ test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
	print >> "$MAILDIRS/Filters.sieve"
    done

cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto "zz.blacklist"; stop; }

# bounces
if header :contains "Sender" "bounce" {
    fileinto "zz.bounces";
    stop;
}

#############
# own filters
EOF

# continue later on while we parse filters

touch "$MAILDIRS/Filters.txt"

    ##########
    # PROCMAIL
    ${=mkdir} "$PROCMAILDIR"
    rm -f "$PROCMAILDIR/rc"
    touch "$PROCMAILDIR/rc"
    cat<<EOF >> "$PROCMAILDIR/rc"
# procmail configuration file generated by Jaro Mail
MAILDIR=\"$MAILDIRS\"
JARO=$WORKDIR/bin/jaro
DEFAULT=\$MAILDIR/unsorted/
VERBOSE=off
LOGFILE=\$MAILDIR/logs/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = "$WORKDIR/.procmail"
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
PF_RECURSE = yes

# blacklist filters
:0 w:
* ? \$JARO -l blacklist -q isknown
zz.blacklist/

# if its a mailinglist bounce, save it to zz.bounces
:0
* ^Sender: mailman-bounce
zz.bounces/

# filters generated from Filters.txt
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    act "compiling rules for mailinglists"
    print "# filters generated from Filters.txt" >> "$PROCMAILDIR/rc"

    typeset -alU filter_from
    typeset -alU filter_to

    for f in `cat "$MAILDIRS/Filters.txt" | awk '
    /^#/ {next}
    /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> "$PROCMAILDIR/rc"
		func "messages to <${address}> in folder: ${destination}"
		maildirmake "$MAILDIRS/$destination"
		filter_to+=($address)
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> "$PROCMAILDIR/rc"
		func "messages from <${address}> in folder: {$destination}"
		maildirmake "$MAILDIRS/$destination"
		filter_from+=($address)
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	print  " \\" >> "$MUTTDIR/mboxes"
	print -n " +${destination} " >> "$MUTTDIR/mboxes"
    done

    # now do the sieve
    { test ${#filter_to} -gt 0 } && {
	cat <<EOF >> "$MAILDIRS/Filters.sieve"
# filter to
if header :contains "To" [
EOF
	c=${#filter_to}
	for f in ${(k)filter_to}; do
	    print -n "\"$f\"" >> $sieve
	    c=$(( $c - 1 ))
	    { test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
	    print >> "$MAILDIRS/Filters.sieve"
	done
	cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto "filters"; stop; }

EOF
    }

    { test ${#filter_from} -gt 0 } && {
	cat <<EOF >> "$MAILDIRS/Filters.sieve"
# filter from
if header :contains "From" [
EOF
	c=${#filter_from}
	for f in ${(k)filter_from}; do
	    print -n "\"$f\"" >> $sieve
	    c=$(( $c - 1 ))
	    { test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
	    print >> "$MAILDIRS/Filters.sieve"
	done
	cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto "filters"; stop; }

EOF
    }

    ##############################################################
    # if the sender is known (whitelist) then put mail in
    # high priority 'known' (procmail) or INBOX (sieve)



#### SIEVE
act "compiling whitelist rules from addressbook"
func "generating whitelist for sieve filters"
cat <<EOF >> "$MAILDIRS/Filters.sieve"
# whitelist
if header :contains "From" [
EOF

newlock "$TMPDIR/whitelist.sieve.$id"

cat <<EOF | ${SQL} -batch ${addressbook} \
    >> "$TMPDIR/whitelist.sieve.$id"
SELECT email FROM whitelist;
EOF
typeset -alU whitelist
for i in `cat "$TMPDIR/whitelist.sieve.$id"`; do
    whitelist+=("$i"); done

unlink "$TMPDIR/whitelist.sieve.$id"

c=${#whitelist}
for w in $whitelist; do
    print -n "\"$w\"" >> "$MAILDIRS/Filters.sieve"
    c=$(( $c - 1 ))
    { test $c != 0 } && { print -n "," >> "$MAILDIRS/Filters.sieve" }
    print >> "$MAILDIRS/Filters.sieve"
done
cat <<EOF >> "$MAILDIRS/Filters.sieve"
]
{ fileinto "INBOX"; stop; }

# spam
if header :is "X-Spam-Flag" "YES" {
    fileinto "zz.spam";
    stop;
}

fileinto "unsorted";
EOF

unlock $sieve

return 0

}



    # conclude sieve
cat <<EOF >> "$MAILDIRS/Filters.sieve"

fileinto "unsorted";
EOF

unlock "$MAILDIRS/Filters.sieve"

    return 0
} # end of update()
