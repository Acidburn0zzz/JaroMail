#!/usr/bin/env zsh
#
# Postino, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=0.6
DATE=March/2011
POSTINOEXEC=$0
typeset -a OLDARGS
for arg in ${argv}; do OLDARGS+=($arg); done

##########################
# declare global variables

QUIET=0
DEBUG=1

# default config dir
if [ -z $POSTINO_DIR ]; then
    WORKDIR=$HOME/.postino
else
    WORKDIR=$POSTINO_DIR
fi

##########################


PARAM=()
typeset -A global_opts
typeset -A opts

autoload colors; colors

# standard output message routines
# it's always useful to wrap them, in case we change behaviour later
notice() { if [[ $QUIET == 0 ]]; then print "$fg_bold[green][*]$fg_no_bold[white] $1" >&2; fi }
error()  { if [[ $QUIET == 0 ]]; then print "$fg[red][!]$fg[white] $1" >&2; fi }
func()   { if [[ $DEBUG == 1 ]]; then print "$fg[blue][D]$fg[white] $1" >&2; fi }
act()    {
    if [[ $QUIET == 0 ]]; then
	if [ "$1" = "-n" ]; then
	    print -n "$fg_bold[white] . $fg_no_bold[white] $2" >&2;
	else
	    print "$fg_bold[white] . $fg_no_bold[white] $1" >&2;
	fi
    fi
}

# make sure the directory is private
chmod 700 $WORKDIR
if [ $? != 0 ]; then
    error "Postino directory $WORKDIR is not private, set permissions to 700"
    error "Refusing to proceed."
    exit 1
fi

# make sure we have a temp and cache dir
mkdir -p $WORKDIR/tmp $WORKDIR/cache
chmod 700 $WORKDIR/tmp $WORKDIR/cache




# we use pinentry
# comes from gpg project and is secure
# it also conveniently uses the right toolkit
ask_password() {

    # pinentry has no custom icon setting
    # so we need to temporary modify the gtk theme
    if [ -r /usr/local/share/themes/tomb/gtk-2.0-key/gtkrc ]; then
	GTK2_RC=/usr/local/share/themes/tomb/gtk-2.0-key/gtkrc
    elif [ -r /usr/share/themes/tomb/gtk-2.0-key/gtkrc ]; then
	GTK2_RC=/usr/share/themes/tomb/gtk-2.0-key/gtkrc
    fi

    cat <<EOF | GTK2_RC_FILES=${GTK2_RC} pinentry 2>/dev/null | awk '/^D / { sub(/^D /, ""); print }'
OPTION ttyname=$TTY
OPTION lc-ctype=$LANG
SETTITLE Insert tomb password
SETDESC Open tomb: $1
SETPROMPT Password:
GETPIN
EOF

}

option_is_set() {
    #First argument, the option (something like "-s")
    #Second (optional) argument: if it's "out", command will print it out 'set'/'unset'
    #                       This is useful for if conditions
    #Return 0 if is set, 1 otherwise
    [[ -n ${(k)opts[$1]} ]];
    r=$?
    if [[ $2 == out ]]; then
        if [[ $r == 0 ]]; then
            echo 'set'
        else
            echo 'unset'
        fi
    fi
    return $r;
}
option_value() {
    #First argument, the option (something like "-s")
    <<< ${opts[$1]}
}
maildirmake() {

    if [ -z $1 ]; then
	error "internal error: missing argument for maildirmake"
	return
    fi

    if [ -r $1 ]; then
	func "maildir exists: $1"
	return
    fi

    mkdir -p ${1}/cur
    mkdir -p ${1}/new
    mkdir -p ${1}/tmp
    
    chmod -R 700 $1
}

queue() {
    local base;
    local tmp;
    local mailfile;
    local msmtpfile;

    # add mails to the sendout queue
    mkdir -p $MAILDIRS/queue
    umask 077
    cd $MAILDIRS/queue || return 1
    # Create new unique filenames of the form
    # MAILFILE:  ccyy-mm-dd-hh.mm.ss[-x].mail
    # MSMTPFILE: ccyy-mm-dd-hh.mm.ss[-x].msmtp
    # where x is a consecutive number only appended if you send more than one 
    # mail per second.
    base="`date +%Y-%m-%d-%H.%M.%S`"
    echo "[$base] queue called with params: ${PARAM[@]}" > $WORKDIR/queue.log

    if [ -f "$base.mail" -o -f "$base.msmtp" ]; then
	tmp="$base"
	i=1
	while [ -f "$tmp-$i.mail" -o -f "$tmp-$i.msmtp" ]; do
		i=`expr $i + 1`
	done
	base="$base-$i"
    fi
    mailfile="$base.mail"
    msmtpfile="$base.msmtp"
    # Write command line to $MSMTPFILE
    echo "$@" > "$msmtpfile" || return 1
    # Write the mail to $MAILFILE
    cat > "$mailfile" || return 1
    return 0
}


######
# SMTP
send() {
    # this function should send all mails in queue
 
    local -aU smtp_set #behave like a set; that is, an array with unique elements
    smtp_set=`awk '!/^#/ { print $1 ";" $2 ";" $3 }' $WORKDIR/send.conf`
    for s in ${(f)smtp_set}; do
	sname="${s[(ws:;:)1]}"
	shost="${s[(ws:;:)2]}"
	slogin="${s[(ws:;:)3]}"
	func "SMTP: $sname $slogin $shost:$sport"
    done
    error "TODO"
    return 0
}

######
# IMAP
peek() {
    # this function will open the MTA to the imap server without fetching mails locally
    local -aU imap_set #behave like a set; that is, an array with unique elements
    imap_set="${IMAP_LOGIN};${IMAP_ADDRESS};${IMAP_PORT}"
    for i in ${(f)imap_set}; do
	ilogin="${i[(ws:;:)1]}"
	ihost="${i[(ws:;:)2]}"
	iport="${i[(ws:;:)3]}"
	func "IMAP: $ilogin $ihost:$iport"
	# if there is a selection, check if its the one
	if [ $1 ] && [ "$1" == "$iname" ]; then break;
	elif ! [ $1 ]; then break; fi # no selection: take first as default
    done
    # escape at sign in login
    mutt -f imaps://`echo $ilogin | sed 's/@/\\@/'`@${ihost}
    return 0
}

sync() {
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...
    
    # debug configuration
    func "WORKDIR: $WORKDIR"
    func "MAILDIRS: $MAILDIRS"

    # make sure maildirs where to put mails exist
    mkdir -p $MAILDIRS
    chmod 700 $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    
    ######
    # MUTT
    if ! [ -z $MUTTDIR ]; then
	mkdir -p $MUTTDIR
	rm -f $MUTTDIR/rc
	cat<<EOF > $MUTTDIR/rc
# mutt config generated by postino
unset use_domain
set hostname = $DOMAIN
set realname = $NAME
set folder = $MAILDIRS
set spoolfile = $MAILDIRS/known/
set record = $MAILDIRS/sent/
set postponed= $MAILDIRS/postponed/
set tmpdir = $WORKDIR/tmp
set query_command = "postino query '%s'"
set sendmail = "postino queue"
set header_cache= $MUTTDIR/cache
set maildir_header_cache_verify=no
set editor = "$EDITOR"
set mailcap_path = "$WORKDIR/mailcap"

# mailboxes in order of priority
source $MUTTDIR/mboxes
EOF

	if [ -r $MUTTDIR/general ]; then
	    echo "# user tweaked configuration" >> $MUTTDIR/rc
	    echo "source ${MUTTDIR}/general" >> $MUTTDIR/rc
	fi
	echo "## end of generated muttrc" >> $MUTTDIR/rc
	echo "##########################" >> $MUTTDIR/rc
	echo >> $MUTTDIR/rc

        # just the header, will be completed later in procmail loop
	rm -f $WORKDIR/mutt/mboxes
	echo -n "mailboxes +priv" > $WORKDIR/mutt/mboxes
    fi
    
    ##########
    # PROCMAIL
    mkdir -p $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by postino
MAILDIR=$MAILDIRS
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=$PROCMAILDIR/log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke
#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = /usr/share/procmail-lib
#  Load the central initial startup code.
INCLUDERC = $PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
# don't save multiple copies
PF_RECURSE = yes
:0
* ? test pf-chkto.rc
{
# filters generated from postino filters.conf
EOF
    for f in `cat $WORKDIR/filters.conf | awk '/^#/ {next} /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}\tINCLUDERC=$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}\tINCLUDERC=$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		;;
	    *)
		error "unsupported in filters.conf: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	echo  " \\" >> $MUTTDIR/mboxes
	echo -n " +${destination} " >> $MUTTDIR/mboxes
    done

    echo " \\" >> $MUTTDIR/mboxes
    echo " +unsorted" >> $MUTTDIR/mboxes
    uniq $MUTTDIR/mboxes > $WORKDIR/tmp/mboxes
    mv $WORKDIR/tmp/mboxes $MUTTDIR/mboxes
    rm -f $WORKDIR/tmp/mboxes

    cat <<EOF >> $WORKDIR/procmail/rc
}

# save the mails
:0
* PF_DEST ?? .
* ? test $PMSRC/pf-save.rc
{ INCLUDERC=$PMSRC/pf-save.rc }

# if the sender is known (ldbd recognizes it) then put mail in high priority 'known'
:0 w:
* ? formail -x"From:" | head -n1 | tr 'A-Z' 'a-z' | sed 's/.*\W\([0-9a-z_.-]\+@[0-9a-z_.-]\+\).*/\1/' | xargs lbdbq
known/

# if got here, go to unsorted

# save the mails
:0
* PF_DEST ?? .
* ? test $PMSRC/pf-save.rc
{ INCLUDERC=$PMSRC/pf-save.rc }

EOF
    return 0
}


main()
    {
    local -A subcommands_opts
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
    #              DON'T DO IT!
    #     There are two reasons for that:
    #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n)
    subcommands_opts[__default]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]="k -keep=k"
    subcommands_opts[send]=""
    subcommands_opts[peek]=""    
    subcommands_opts[sync]=""
    subcommands_opts[conf]=""
    subcommands_opts[list]=""
    subcommands_opts[source]=""
#    subcommands_opts[mount]=${subcommands_opts[open]}
#    subcommands_opts[create]="s: -size=s -ignore-swap k: -key=k"
    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
        for opt in ${=optspec}; do
            every_opts+=${opt}
        done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
        subcommand="__default"
    fi
    if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then #there's no such subcommand
        error "Subcommand '$subcommand' doesn't exist"
        exit 127
    fi
    argv=(${oldstar})
    unset oldstar

    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
        zparseopts -M -E -D -Aopts ${cmd_opts}
	if [[ $? != 0 ]]; then
	    error "Some error occurred during option processing."
	    exit 127
	fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
#    PARAM=()
    for arg in $*; do
	if [[ $arg == '--' || $arg == '-' ]]; then
	    ok=1
	    continue #it shouldnt be appended to PARAM
	elif [[ $arg[1] == '-'  ]]; then
	    if [[ $ok == 0 ]]; then
		error "unrecognized option $arg"
		exit 127
	    fi
	fi
	PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
	PARAM[1]=()
	shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then act "Postino - $VERSION"; fi
    if option_is_set -h; then error "TODO usage here"; fi
    if option_is_set -q; then QUIET=1; fi
    if option_is_set -D; then func "Debug messages ON"; DEBUG=1; fi
        
    case "$subcommand" in
	queue) queue ${PARAM} ;;
	fetch) ;;
	send) ;;
	peek) peek ;;
	sync) sync ;;
	conf) ;;
	'source')   return 0 ;;
	__default) ;;
	*) error "command \"$subcommand\" not recognized"
	    act "try -h for help"
	    return 1
	    ;;
    esac
    return 0
}

main $@
