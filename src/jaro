#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=0.9
DATE=Jun/2012
JAROMAILEXEC=$0
typeset -a OLDARGS
for arg in ${argv}; do OLDARGS+=($arg); done

##########################
# declare global variables

QUIET=0
DEBUG=0
DRYRUN=0
CLEANEXIT=1
TMPRAM=0

# which command to use when creating dirs
mkdir="`which mkdir` -m 700 -p"
# date stamp
datestamp=`date '+%d%b%y'`
##########################


PARAM=()
typeset -A global_opts
typeset -A opts

# global variable for account selection
typeset -h account
account=default
typeset -h list
list=whitelist

# global variables for accounts
typeset -h name login host protocol port password auth folders accountopt

# global variable for exit code
typeset exitcode
exitcode=0

autoload colors; colors

# standard output message routines
# it's always useful to wrap them, in case we change behaviour later
notice() { if [[ $QUIET == 0 ]]; then print "$fg_bold[green][*]$fg_no_bold[default] $1" >&2; fi }
error()  { if [[ $QUIET == 0 ]]; then print "$fg[red][!]$fg[default] $1" >&2; fi }
func()   { if [[ $DEBUG == 1 ]]; then print "$fg[blue][D]$fg[default] $1" >&2; fi }
act()    {
    if [[ $QUIET == 0 ]]; then
	if [ "$1" = "-n" ]; then
	    print -n "$fg_bold[white] . $fg_no_bold[default] $2" >&2;
	else
	    print "$fg_bold[white] . $fg_no_bold[default] $1" >&2;
	fi
    fi
}

# honor quiet flag as early as possible
echo "${@}" | grep '\-q' > /dev/null # silent
if [ "$?" = 0 ]; then QUIET=1; fi


# what operating system are we in? use os_detect()
# simplifying modes of operation: GNU or MAC
case $(uname) in
    Linux) OS=GNU
	notice "Jaro Mail v$VERSION running on GNU/Linux"	;;

    Darwin) OS=MAC
	notice "Jaro Mail v$VERSION running on Mac/OSX"	;;

    *) OS=GNU # default
	error "Running on an unknown operating system, assuming GNU" ;;
esac

if [ -z $MAILDIRS ]; then
    # check if we are inside the directory
    if [ -r jaro/bin/jaro ]; then
	MAILDIRS=`pwd`
    else # else use default
	MAILDIRS=$HOME/Mail
    fi
fi


# default working dir
WORKDIR=$MAILDIRS/jaro

${=mkdir} $MAILDIRS
${=mkdir} $WORKDIR

# make sure the directory is private
chmod 700 $WORKDIR


# temporary directory
TMPDIR=$WORKDIR/tmp
case $OS in
    GNU)
	touch /dev/shm/jaromail.test.tmp > /dev/null
	{ test $? = 0 } && {
	# we can use volatile ram
	    rm -f /dev/shm/jaromail.test.tmp
	    TMPDIR=/dev/shm/jaromail.$USER
	    TMPRAM=1
	}
	;;
    MAC)
	mount | grep 'JaroTmp' > /dev/null
	{ test $? = 0 } && {
	    # our RAM temp directory is active
	    TMPDIR=/Volumes/JaroTmp/jaromail.$USER
	    TMPRAM=1
	}
	;;
esac

{ test $TMPRAM = 1 } && {
    act "Using temporary directory in volatile RAM" }


# make sure we have a temp and cache dir
${=mkdir} "$TMPDIR"
{ test $? != 0 } && {
    error "Cannot create temporary directory: $TMPDIR"
    return 1 }

${=mkdir} "$WORKDIR/cache"
${=mkdir} "$WORKDIR/log"
${=mkdir} "$WORKDIR/certs"

PROCMAILDIR=$WORKDIR/.procmail
MUTTDIR=$WORKDIR/.mutt


# use gnome-keyring for passwords on GNU systems
GNOMEKEY=0
ps ax | grep '[g]nome-keyring-daemon' > /dev/null
{ test $? = 0 } && {
    which jaro-gnome-keyring > /dev/null
    { test $? = 0 } && { GNOMEKEY=1 }
}


cleanexit() {
    func "Clean exit procedures"
    # while ( ps ax | grep '[s]rm' > /dev/null
    # 	test $? = 0 ); do sleep 1; done

    # for f in `ls $TMPDIR/ | grep -v '.lock$'`; do
    # 	{ test ! -r $TMPDIR/$f.lock } && { unlink $TMPDIR/$f }
    # done

#    { test $TMPRAM = 1 } && { rmdir $TMPDIR }
    unset typeset -h name login host protocol port password auth folders accountopt
}
# make sure tmp is wiped from sensitive data in case of sigINT
TRAPINT() {
	error "Caught signal, aborting operations."
	{ test $CLEANEXIT = 1 } && { cleanexit }
	if [ "$DEBUG" = "1" ]; then
	    return 1
	else
	    exit 1
	fi
}

lock() {
    func "lock: $1"
    $WORKDIR/.lbdb/dotlock ${1}
    case $? in
	1) error "Cannot lock non existing file: $1"
	    return 1 ;;
	3) error "Locked file in use: $1"
	    return 3 ;;
	5) error "Impossible to lock: $1"
	    return 5 ;;
	# success
	0) echo "$$" > ${1}.pid
	    return 0 ;;
    esac
}
newlock() { # create locked
    func "creating locked file: $1"
    touch $1
    chmod 600 $1
    lock $1
    echo "$$" > ${1}.pid
}
unlock() {
    func "unlock: $1"
    lockpid="`cat ${1}.pid`"
    { test "$$" != "$lockpid" } && {
	error "Unlock attempt by different PID: $1"
	error "Created by $lockpid now $$ is trying to unlock"
	return 1
    }
    $WORKDIR/.lbdb/dotlock -u ${=@}
    if [ $? != 0 ]; then
	error "Unable to unlock: $1"
	return 1
    fi
    rm -f ${1}.pid
    return 0
}
unlink() { # delete a file that we are locking
    func "unlink: $1"
    # use with care! this can permanently erase currently locked files
    # only the locking PID should use it on its own locks
    lockpid="`cat ${1}.pid`"
    { test "$$" != "$lockpid" } && {
	error "Unlock attempt by different PID: $1"
	error "Created by $lockpid now $$ is trying to unlock"
	return 1
    }
    (
	${=rm} ${1}
	touch ${1}
	$WORKDIR/.lbdb/dotlock -d -f ${1}
	rm -f ${1}.pid
    ) &!
    return 0
}


# we use pinentry
# comes from gpg project and is secure
# it also conveniently uses the right toolkit
pin_entry() {
    	cat <<EOF | pinentry 2>/dev/null | awk '/^D / { sub(/^D /, ""); print }'
OPTION ttyname=$TTY
OPTION lc-ctype=$LANG
SETTITLE Type your password
SETDESC Type the password for $1 @ $2
SETPROMPT Password:
GETPIN
EOF
}


check_bin() {
    # check for required programs
    for req in pinentry fetchmail procmail mutt; do
	which $req >/dev/null
	{ test $? != 0 } && {
	    error "Cannot find $req. Please install it."
	    return 1
	}
    done

    # which wipe command to use
    which wipe > /dev/null
    { test $? = 0 } && {
	rm="wipe -f -s -q -R /dev/urandom"; return 0 }
    which srm > /dev/null
    { test $? = 0 } && {
	rm="srm -m"; return 0 }
    rm="rm -f"
    return 0
}

# retrieve a password for user @ domain
# put it in variable password
# up to the caller to unset it after use
ask_password() {
    func "Looking for password in keyring: $name"
    case $OS in
	MAC)
	    security find-internet-password \
		-c JARO -a $email -s $host \
		-p $transport -P $port > /dev/null
	    if [ $? != 0 ]; then # its a new password
		new_password
		{ test $? != 0 } && {
		    error "Password input aborted."
		    return 1 }
	    else
		password=`security find-internet-password -c JARO -a $email -s $host -p $transport -P $port -g 2>&1| awk '/^password:/ { print $2 }' | sed -e 's/"//g'`
	    fi
	    return 0
	    ;;
	#####################################
	GNU)
	    func "Looking for password in keyring: $name"
	    ###################
	    # USE GNOME KEYRING
	    { test $GNOMEKEY = 1 } && {
		echo "protocol=${type}\npath=jaromail/${email}\nusername=${login}\nhost=${host}\n\n" \
		    | $WORKDIR/bin/jaro-gnome-keyring check
		if [ $? != 0 ]; then # its a new password
		    new_password
		    { test $? != 0 } && {
			error "Password input aborted."
			return 1 }
		else # password found into gnome keyring
		    act "Using saved password for $1 @ $2"
		    password=`echo "protocol=${type}\npath=jaromail/${email}\nusername=${login}\nhost=${host}\n\n" | $WORKDIR/bin/jaro-gnome-keyring get`
		fi
		return 0
	    }
	    ####################
	    # USE PINENTRY ALONE
	    new_password
	    { test $? = 0 } && {
		error "Password input aborted."
		return 1 }
	    return 0
	    ;;
	*)
	    error "Unknown system, can't figure out how to handle passwords"
	    return 1
    esac
}

new_password() {
    notice "Setting a new password for $name"
    password=`pin_entry $login $host`
    res=0
    case $OS in
	MAC)
	    if [ "$password" != "" ]; then
		security add-internet-password \
		    -c JARO -a $email -s $host \
		    -p $transport -P $port -w "${password}"
		{ test $? != 0 } && {
		    unset password
		    error "Error adding password to keyring."
		    return 1 }
		act "New password set."
		return 0
	    else
		security delete-internet-password \
		    -c JARO -a $email -s $host \
		    -p $transport -P $port > /dev/null
		res=$?; unset password
		{ test $res != 0 } && {
		    error "Error deleting password from keyring."
		    return 1 }
		act "No new password given, old password erased."
		return 0
	    fi
	    ;;
	GNU)
	    if [ "$password" != "" ]; then # password was written

		# USE GNOME KEYRING
		{ test $GNOMEKEY = 1 } && {

		    cat <<EOF | $WORKDIR/bin/jaro-gnome-keyring store
protocol=${type}
path=jaromail/${email}
username=${login}
host=${host}
password=${password}
EOF
		    { test $? != 0 } && {
			unset password
			error "Error saving password in Gnome keyring"
			return 1 }
		    return 0
		}

		return 0

	    else # password is blank or aborted

		# USE GNOME KEYRING
		{ test $GNOMEKEY = 1 } && {

		    cat <<EOF | $WORKDIR/bin/jaro-gnome-keyring erase
protocol=${type}
path=jaromail/${email}
username=${login}
host=${host}
EOF
		    { test $? != 0 } && {
			error "Error accessing password in Gnome keyring"
			return 1 }
		    act "No new password given, old password erased."
		    return 0
		}

		return 1

	    fi
	    ;;
	*)
	    error "Unknown system, can't figure out how to handle passwords"
	    return 1
    esac
}
switch_identity() {
    if [ "$name" != "" ]; then
	act "switch to identity: $name <$login>"
	rm -f $MUTTDIR/identity
	cat <<EOF > $MUTTDIR/identity
set hostname = $host
set realname = "$name"
set from = "$name <$login>"
EOF
    else
	error "No identity found, left blank."
	touch $MUTTDIR/identity
    fi
}


option_is_set() {
    #First argument, the option (something like "-s")
    #Second (optional) argument: if it's "out", command will print it out 'set'/'unset'
    #                       This is useful for if conditions
    #Return 0 if is set, 1 otherwise
    [[ -n ${(k)opts[$1]} ]];
    r=$?
    if [[ $2 == out ]]; then
	if [[ $r == 0 ]]; then
	    echo 'set'
	else
	    echo 'unset'
	fi
    fi
    return $r;
}
option_value() {
    #First argument, the option (something like "-s")
    <<< ${opts[$1]}
}
maildirmake() {

    if [ -z $1 ]; then
	error "internal error: missing argument for maildirmake"
	return
    fi

    if [ -r $1 ]; then
	func "maildir exists: $1"
	return
    fi

    ${=mkdir} ${1}/cur
    ${=mkdir} ${1}/new
    ${=mkdir} ${1}/tmp

}
# arg 1 : account type, es: imap or smtp
# -a defines which account name other than 'default'
read_account() {
    typeset -al all

    if [ -z $1 ]; then
	type=`echo $account | cut -d. -f1`
	account=`echo $account | cut -d. -f2`
    else type=$1 # smtp, imap, pop ... file prefixes"
    fi

    # find the file
    for a in `find $WORKDIR/Accounts -name "$type.$account*"`; do all+=($a); done
    if [ ${#all} = 0 ]; then
	error "No $type account found: $account"
	error "Refine your argument using '-a type.account'"
	error "For instance: jaro -a imap.default"
	error "Available accounts (excluding symbolic links):"
	for a in `find $WORKDIR/Accounts -type f | grep -v README`; do
	    act -n "`basename $a` :: "
	    awk '
/^name/ { for(i=2;i<=NF;i++) printf "%s ", $i }
/^email/ { printf "<%s>", $2 }
/^host/ { printf " on %s", $2 }
{next}' $a
	    echo " (`basename $a | cut -d. -f1`)"
	done
	return 1
    elif [ ${#all} != 1 ]; then
	error "Too many $type accounts named $account"
	act -n ""
	for i in ${=all}; do echo -n "`basename ${i}` "; done
	echo; error "Refine your account keyword using -a option"
	return 1
    fi

    acct=${all[1]}
    type=`basename $acct | cut -d. -f1`

    case $type in
	imap|smtp)

	    lock $acct
	    ttmp=`cat $acct | awk '
    /^#/ { next }
    /^name/ { printf "name=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^email/ { printf "email=\"%s\";", $2 }
    /^host/ { printf "host=\"%s\";", $2 }
    /^login/ { printf "login=\"%s\";", $2 }
    /^transport/ { printf "transport=\"%s\";", $2 }
    /^port/ { printf "port=\"%s\";", $2 }
    /^password/ { printf "password=\"%s\";", $2 }
    /^auth/ { printf "auth=\"%s\";", $2 }
    /^cert/ { printf "cert=\"%s\";", $2 }
    /^options/ { printf "accountopt=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^folders/ { printf "folders=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    '`
	    unlock $acct

	    eval "$ttmp"
	    # check required fields
	    { test -z $host }  && { error "Field missing in account $acct: host"; return 1 }

	    # fill in defaults
	    { test -z $name }       && { name="$type" }
	    { test -z $login }      && { login="$email" } # usually email and login are the same
	    { test -z $email }      && { email="$login" } # so if one is specified, deduce the other
	    { test -z $transport }  && { transport=plain }
	    { test -z $port }       && { port=143 }
	    { test -z $auth }       && { auth=plain }
	    { test -z $cert }       && { cert=ignore }
	    { test -z $accountopt } && { accountopt=keep }
	    # cert and password can be missing

	    func "type: $type"
	    func "name: $name"
	    func "email: $email"
	    func "host: $host"
	    func "login: $login"
	    func "trans: $transport"
	    func "port: $port"
	    func "cert: $cert"
	    func "auth: $auth"
	    func "options: $accountopt"
	    func "folders: $folders"
	    ;;
	*)
	    error "Account type \"$type\" not recognized."
	    return 1
	    ;;
    esac
    return 0
}

# start without options: auto
# read or compose depending if there is an argument that is an email
# or a folder to start with

autostart() {
# no argument passed. open known folder
    { test -z ${1} } && {

	{ test ! -r $MUTTDIR/rc } \
	    && { error "Jaro Mail is not yet configured."; return 1 }

	mutt -F $MUTTDIR/rc
	return $?
    }

    # argument passed: determine if an email or a folder
    echo "${1}" \
	| tr 'A-Z' 'a-z' \
	| grep '^[a-zA-Z0-9._%+-]*@[a-zA-Z0-9]*[\.[a-zA-Z0-9]*]*[a-zA-Z0-9]$' \
	> /dev/null
    { test $? = 0 } && {
	notice "Composing message to: ${1}"
	# its an email, TODO see if we have it in our addressbook
	mutt -F $MUTTDIR/rc "${1}"
	return 0
    }

    { test -r $MAILDIRS/${1} } && {
	notice "Opening folder ${1}"
	mutt -F $MUTTDIR/rc -f "$MAILDIRS/${1}"
	return 0
    }

    return $?
}

queue() {
    local base;
    local tmp;
    local mailfile;
    local msmtpfile;

    # add mails to the sendout queue
    ${=mkdir} $MAILDIRS/outbox
    cd $MAILDIRS/outbox || return 1
    notice "Adding mail to the outbox queue"
    # Create new unique filenames of the form
    # MAILFILE:  ccyy-mm-dd-hh.mm.ss[-x].mail
    # MSMTPFILE: ccyy-mm-dd-hh.mm.ss[-x].msmtp
    # where x is a consecutive number only appended if you send more than one
    # mail per second.
    base="`date +%Y-%m-%d-%H.%M.%S`"
    func "[$base] queue called with params: ${PARAM[@]}"

    if [ -f "$base.mail" -o -f "$base.msmtp" ]; then
	tmp="$base"
	i=1
	while [ -f "$tmp-$i.mail" -o -f "$tmp-$i.msmtp" ]; do
		i=`expr $i + 1`
	done
	base="$base-$i"
    fi
    mailfile="$base.mail"
    msmtpfile="$base.msmtp"
    # Write command line to $MSMTPFILE
    echo "$@" > "$msmtpfile"
    lock $msmtpfile
    # Write the mail to $MAILFILE
    cat > "$mailfile"
    unlock $msmtpfile
    cd -
    return 0
}

######
# CERT
# downloads and/or installs certificates
cert() {
    if [ -z $1 ]; then
	error "Certificate handler called without an argument"
	return 1;
    fi

    certificate="$1"

    case $certificate in
	gmail)
	    cc=Equifax_Secure_Certificate_Authority
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then

		curl -o $WORKDIR/certs/${cc}.pem \
		    "https://www.geotrust.com/resources/root_certificates/certificates/${cc}.cer"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem -fingerprint \
		    -subject -issuer -serial -hash -noout
	    fi
	    ;;
	dyne|autistici|freaknet)
	    cc=Autistici_Certificate_Authority
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then
		curl -o $WORKDIR/certs/${cc}.pem \
		    "http://ca.autistici.org/ca.pem"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem \
		    -fingerprint -subject -issuer -serial -hash -noout
	    fi
	    ;;
	riseup)
	    cc=RiseupCA
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then
		curl -o $WORKDIR/certs/${cc}.pem "https://help.riseup.net/assets/43052/RiseupCA.pem"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem \
		    -fingerprint -subject -issuer -serial -hash -noout
	    fi
	    ;;
	*)
	    cc="`basename $certificate`"
	    curl -o "$WORKDIR/certs/${cc}" "$certificate"
	    if [ $? != 0 ]; then
		error "Error downloading certificate: $certificate"
		return 1
	    fi
	    openssl x509 -in \
		"$WORKDIR/certs/${cc}" \
		-fingerprint -subject -issuer -serial -hash -noout
	    ;;
    esac
    act "refreshing certificates"
    c_rehash $WORKDIR/certs > /dev/null
    if [ $? != 0 ]; then
	error "Error refreshing certificates in $WORKDIR/certs"
	c_rehash $WORKDIR/certs
    fi
    return 0
}

###########
# FETCHMAIL
fetchall() {
    notice "Fetching all accounts in $MAILDIRS"
    res=0
    for i in `find $WORKDIR/Accounts -type f | grep -v README`; do
	a=`basename $i`
	type=`echo $a | cut -d. -f1`
	account=`echo $a | cut -d. -f2`
	func "$account type $type: $a"
	fetch $type
	if [ $? != 0 ]; then res=1; fi
	# returns an error if just one of the accounts did
    done
    return $res
}
fetch() {
    adir=$WORKDIR/Accounts

    typeset -al all

    # recursion here
    if [ -z $1 ]; then fetchall; return $?; fi

    read_account "$1"
    if [ $? != 0 ]; then
	error "Account configuration not found, or broken. Aborting operation."
	return 1
    fi

    if [ "$type" = "smtp" ]; then # we skip smtp in fetch
	return 0; fi

    if ! [ -r $PROCMAILDIR/rc ]; then
	act "updating procmail configuration"
	update
    fi

    notice "Fetching mails for $name"
    ask_password $login $host
    { test $? != 0 } && {
	error "Error retrieving password for $login on $host"
	unset password all; return 1
    }

    tmp=$TMPDIR/$host.fetch.$RANDOM
    newlock $tmp
    cat <<EOF > $tmp
poll $host with proto IMAP user "$login" there with password "$password"
EOF
    unset password

    if ! [ -z $accountopt ]; then # add option configuration
	echo "${accountopt}" >> $tmp; fi

    if ! [ -z $folders ]; then # add folder configuration
	echo "folder ${folders}" >> $tmp; fi

    cat <<EOF >> $tmp
ssl warnings 3600 and wants mda "procmail -m $PROCMAILDIR/rc"
EOF
    if [ "$cert" = "check" ]; then
	cat <<EOF >> $tmp
sslcertck sslcertpath '$WORKDIR/certs'
EOF
    fi
    cat <<EOF >> $tmp
antispam 571 550 501 554
EOF

	# try login without doing anything
    fetchmail -c -f $tmp
	# examine result
    case $? in
	1)
	    notice "No mails for $name"
	    unlink $tmp
	    return 1
		;;
	2)
	    error "Invalid or unknown certificate for $host"
	    unlink $tmp
	    return 1
	    ;;
	3)
	    error "Invalid password for user $login at $host"
	    unlink $tmp
	    return 1
	    ;;
	*) ;;
    esac

	# archive old procmail log
    if [ -r $WORKDIR/log/procmail.log ]; then
	newlock $WORKDIR/log/procmail-${datestamp}.log
	cat $WORKDIR/log/procmail.log \
	    >> $WORKDIR/log/procmail-${datestamp}.log
	rm -f $WORKDIR/log/procmail.log
	unlock $WORKDIR/log/procmail-${datestamp}.log
    fi
    act "please wait while downloading mails..."

    cat $tmp | fetchmail -f $tmp
	# TODO: substitute this with cat conf | fetchmail -f -
	# to avoid writing the password in clear on filesystem

    unlink $tmp

    total=`mailstat -k $WORKDIR/log/procmail.log | tail -n1 | awk '{print $2}'`
    briefing=`mailstat -kt $WORKDIR/log/procmail.log |awk '!/procmail/ { print "    " $2 "\t" $3 }'|sort -nr`
    notice "$total emails fetched"
    echo "${briefing}"

    return 0
}

stats() {
    mailstat -k $WORKDIR/log/procmail.log
    return $?
}

######
# SEND
# this function should send all mails in outbox
send() {
    adir=$WORKDIR/Accounts
    acct=$1
    typeset -al all

    # list mails to send
    mailnum=`ls ${MAILDIRS}/outbox | grep 'mail$' | wc -l`
    mailnum=${mailnum// /} # trim whitespace
    if [ "$mailnum" = "0" ]; then
	act "Outbox is empty, no mails to send."
	return 0
    fi

    read_account smtp
    if [ $? != 0 ]; then
	error "Account configuration not found, or broken. Aborting operation."
	return 1
    fi

    notice "Sending out ${mailnum} mails via $name"

    # defaults
    [ -z $auth ] && auth=plain
    [ -z $port ] && port=25


    ask_password $login $host
    { test $? != 0 } && {
	error "Error retrieving password for $login on $host"
	unset password all; return 1
    }

    tmp=$TMPDIR/$host.send.$RANDOM
    newlock $tmp
    cat <<EOF > $tmp
account default
from ${email}
user ${login}
host ${host}
port ${port}
tls on
tls_starttls on
tls_certcheck off
logfile ${WORKDIR}/log/msmtp.log
auth ${auth}
password ${password}
EOF
    unset password

    for mail in `find $MAILDIRS/outbox -name "*.mail"`; do
       smtp=`echo ${mail} | sed -e 's/mail/msmtp/'`
       lock ${smtp}
       recipients="`cat ${smtp}`"
       act "To: ${recipients}"
       msmtp -C $tmp -- ${=recipients} < "${mail}"
       if [ $? != 0 ]; then
	   error "Error sending mail, skipped"
	   unlock ${smtp}
       else
	   act "Mail sent succesfully"
	   # whitelist those to whom we send mails
	   cat ${mail} | $WORKDIR/bin/jaro -l whitelist -q learn to:
	   ${=rm} ${mail} &
	   unlink ${smtp} &
       fi
    done
    unlink $tmp
    return 0
}

######
# PEEK
# this function will open the MTA to the imap server without fetching mails locally
peek() {
    read_account imap
    if [ $? != 0 ]; then
	error "Account configuration not found, or broken. Aborting operation."
	return 1
    fi

    notice "Peek into remote imap account $name"

    folder=""
    if ! [ -z ${1} ]; then
	folder="/${1}"
	act "opening folder ${folder}"
    fi

    switch_identity
    case $transport in
	ssl) act "using secure connection (SSL)"
	    iproto="imaps" ;;
	plain) act "using clear text connection"
	    iproto="imap"  ;;
    esac
    # escape at sign in login
    ilogin=`echo $login | sed 's/@/\\@/'`

    ask_password $login $host
    { test $? != 0 } && {
	error "Error retrieving password for $login on $host"
	unset password all; return 1
    }
    tmp=$TMPDIR/$host.peek.$RANDOM
    newlock $tmp
    cat <<EOF >> $tmp
set imap_pass = "${password}"
# set imap_peek = yes
EOF
    unset password
    echo "source $tmp" >> $MUTTDIR/password
    (sleep 1;
	cp /dev/null $MUTTDIR/password
	cp /dev/null $tmp
	unlink $tmp
    ) &
    mutt -F $MUTTDIR/rc	-f ${iproto}://${ilogin}@${host}${folder}
    return $?
}

update() {
    notice "Updating all configurations and filters"
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...

    # debug configuration
    func "MAILDIRS:    $MAILDIRS"
    func "WORKDIR:     $WORKDIR"
    func "MUTTDIR:     $MUTTDIR"
    func "PROCMAILDIR: $PROCMAILDIR"

    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    maildirmake $MAILDIRS/ml.unsorted
    ${=mkdir} $MAILDIRS/outbox

    ######
    # MUTT
    ${=mkdir} $MUTTDIR
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = $MAILDIRS
set spoolfile = $MAILDIRS/known/
set record = $MAILDIRS/sent/
set postponed= $MAILDIRS/postponed/
set tmpdir = $WORKDIR/cache
set sendmail = "$WORKDIR/bin/jaro queue"
set header_cache= $WORKDIR/cache
set maildir_header_cache_verify=no
set editor = "$WORKDIR/bin/jaro edit"
set mailcap_path = "$WORKDIR/.mutt/mailcap:$WORKDIR/mailcap:$HOME/.mailcap:/etc/mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"

# Little Brother Database
set query_command = "$WORKDIR/bin/jaro -q addr '%s'"
macro index,pager a "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q learn from:<enter>" "add to whitelist everyone in the message"
macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -l whitelist -q forget from:<enter>" "remove sender from whitelist
macro index,pager z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q learn from:<enter>" "add sender to blacklist"
macro index,pager Z "<pipe-message>$WORKDIR/bin/jaro -l blacklist -q forget from:<enter>" "remove sender from blacklist

# mailboxes in order of priority
source $MUTTDIR/mboxes

# specific configuration files
source $MUTTDIR/crypto
source $MUTTDIR/colors
source $MUTTDIR/general
source $MUTTDIR/formats
source $MUTTDIR/keybindings
source $MUTTDIR/identity
source $MUTTDIR/password
source $WORKDIR/Mutt.txt
## end of Jaro Mail generated muttrc
####################################

EOF

   # making sure we have the minimum mailcap necessary
wwwtext=w3m
{ which lynx > /dev/null } && { wwwtext=lynx }
{ which elinks > /dev/null } && { wwwtext=elinks }
cat <<EOF > $MUTTDIR/mailcap
text/html; ${wwwtext} -dump %s; nametemplate=%s.html; copiousoutput

text/plain; iconv -f iso-8859-1 -t utf-8; test=charset=%{charset} \
  && test x`echo \"$charset\" | tr a-z A-Z` = xISO-8859-1; copiousoutput
text/plain; cat %s
EOF

    # this one is empty and sources files in temp when necessary
    touch $MUTTDIR/password

    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    echo -n "mailboxes +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_account imap

    switch_identity

    ##########
    # PROCMAIL
    act "generating procmail filters"
    ${=mkdir} $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by Jaro Mail
MAILDIR=$MAILDIRS
JARO=$WORKDIR/bin/jaro
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=$WORKDIR/log/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = $PROCMAILDIR
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
PF_RECURSE = yes

# blacklist filters using lbdb
:0 w:
* ? \$JARO -l blacklist -q query from:
zz.blacklist/

# filters generated from Filters.txt
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    echo "# filters generated from Filters.txt" >> $PROCMAILDIR/rc

    for f in `cat $WORKDIR/Filters.txt | awk '/^#/ {next} /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		func "messages to <${address}> in folder: ${destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		func "messages from <${address}> in folder: {$destination}"
		maildirmake $MAILDIRS/$destination
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	echo  " \\" >> $MUTTDIR/mboxes
	echo -n " +${destination} " >> $MUTTDIR/mboxes
    done

    # if the sender is known (ldbd recognizes it) then put mail in high priority 'known'
    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }


# whitelisting filters using lbdb
:0 w:
* ? \$JARO -l whitelist -q query from:
known/


EOF

    #######
cat <<EOF >> $PROCMAILDIR/rc
# filters generated from Accounts
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF
    typeset -al accts
    for f in `cat $WORKDIR/Accounts/* | awk '/^email/ { print $2 }'`; do
	echo "ADDR=${f}\tDEST=priv/\tINCLUDERC=\$PMSRC/pf-chkto.rc"  >> $PROCMAILDIR/rc
	act "private account: <${f}>"
    done

    cat <<EOF >> $PROCMAILDIR/rc
}

:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }

# if its an unknown mailinglist, save it into ml.unsorted
:0
* ^(List-Id|X-(Mailing-)?List):
ml.unsorted/

EOF

    # MUTT (generate mailboxes priority this parser)
    echo " \\" >> $MUTTDIR/mboxes
    echo " +ml.unsorted +unsorted" >> $MUTTDIR/mboxes

    uniq $MUTTDIR/mboxes > $TMPDIR/mboxes
    mv $TMPDIR/mboxes $MUTTDIR/mboxes
    rm -f $TMPDIR/mboxes

    # conclude
    cat <<EOF >> $PROCMAILDIR/rc

# if got here, go to unsorted
:0:
\$DEFAULT

#
# End of generated procmail rc
#
EOF
    return 0
} # end of update()

###################
# Jaro Brother DB
SQL=sqlite3
create_addressbook() {
    { test -r $WORKDIR/addressbook } && {
	error "Addressbook already exists: $WORKDIR/addressbook"
	return 1
    }
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook
CREATE TABLE whitelist
(
  email   text collate nocase,
  name    text collate nocase unique,
  hits    int
);
CREATE TABLE blacklist
(
  email   text collate nocase,
  name    text collate nocase unique,
  hits    int
);
EOF
    { $? != 0 } && {
	error "Error creating addressbook database."
	return 1 }
    return 0
}
insert_address() {
    func "insert address: $1, $2"
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook 2> /dev/null
INSERT INTO $list (email, name)
VALUES ("${1}", "${2}");
EOF
    { test $? != 0 } && {
	func "address already present in $list" }
    return $0
}
remove_address() {
    func "remove address <$1> from $list"
    cat <<EOF | ${SQL} -batch $WORKDIR/addressbook
DELETE FROM $list
WHERE email LIKE "${1}";
EOF
    { test $? != 0 } && {
	func "address not found or error occurred" }
}
search_name() {
	cat <<EOF | ${SQL} -column -batch $WORKDIR/addressbook
.width 64 128
SELECT * FROM $list
WHERE name LIKE "%${1}%";
EOF
}
search_email() {
	cat <<EOF | ${SQL} -column -batch $WORKDIR/addressbook
SELECT rowid FROM $list
WHERE email IS "${1}";
EOF
return $?
}
address() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    act "Searching for \"${PARAM[1]}\" in $list"
    { test "$OS" = "MAC" } && {
	matches=`$WORKDIR/bin/ABQuery ${PARAM[1]}`
    }
    matches="${matches}\n`search_name ${PARAM[1]}`"

    # mutt query requires something like this
    echo "jaro: `echo $matches | wc -l` matches"
    echo "$matches" | awk '
{ printf "%s\t", $1
  for(i=2;i<=NF;i++) {
    sub("<","",$i)
    sub(">","",$i)
    if($i!=$1) printf "%s ", $i
  }
  printf "\n" }'
}
query() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    if [ -z ${PARAM[1]} ]; then
	email="`${WORKDIR}/bin/fetchaddr -a| awk '{print $1}'`"
    else
	email="`${WORKDIR}/bin/fetchaddr -x ${PARAM[1]} -a| awk '{print $1}'`"
    fi
    exitcode=1
    lookup="`search_email ${email}`"
    { test "$lookup" != "" } && { exitcode=0 }
    act "Email <$email> found in $list with id $lookup"
}

learn() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    tmp=$TMPDIR/learn.$datestamp.$RANDOM
    from="`tee $tmp | formail -xFrom: | sed -e 's/\"//g'`"
    if [ -z ${PARAM[1]} ]; then
	email="`cat $tmp | ${WORKDIR}/bin/fetchaddr| awk '{print $1}'`"
    else
	email="`cat $tmp | ${WORKDIR}/bin/fetchaddr -x ${PARAM[1]}| awk '{print $1}'`"
    fi
    ${=rm} $tmp &
    insert_address "$email" "$from"
}

forget() {
    { test ! -r ${WORKDIR}/addressbook } && { create_addressbook }
    act "Expecting mail from stdin pipe"
    if [ -z ${PARAM[1]} ]; then
	email="`${WORKDIR}/bin/fetchaddr| awk '{print $1}'`"
    else
	email="`${WORKDIR}/bin/fetchaddr -x ${PARAM[1]}| awk '{print $1}'`"
    fi
    remove_address "${email}"
}
list_addresses() {
    { test ${PARAM[1]} } && { list=${PARAM[1]} }
    act "Listing all contents for $list"
    cat <<EOF | ${SQL} -column -header -batch $WORKDIR/addressbook
.width 32 40
SELECT * FROM $list;
EOF

    echo ".dump" | ${SQL} -batch $WORKDIR/addressbook \
	| bzip2 > $WORKDIR/addressbook.bz2
    notice "Backup of all addressbook created"
    act -n ""; ls -lh $WORKDIR/addressbook.bz2
}

###################


#########
## Editor
# this part guesses what is the best editor already present on the system
# of course we have a preference for AutOrg, the editor from our suite
# however the default is nano if nothing else is choosen.
editor() {
    { test ${EDITOR} } && {
	${EDITOR} ${PARAM[1]}
	return $? }
    case $OS in
	MAC) open -t ${PARAM[1]} ;;
	GNU)
	    { which nano > /dev/null } && {
		nano -m -S -Q ">" -I -E -D -T 4 -U -W -c -i -k -r 72 ${PARAM[1]} }
	    error "No editor found, please configure the EDITOR environment variable."
	    sleep 3
	    ;;
    esac
    return $?
}

######################
# Maildir manipulation
backup() {
    src=${PARAM[1]}
    dst=${PARAM[2]}
    expire=${PARAM[3]}
    if ! [ -r ${src}/cur ]; then
	error "No maildir found in $src"
	return 1
    fi
    if ! [ -r ${dst}/cur ]; then
	maildirmake "${dst}"
    fi
    if [ -z $expire ]; then
	error "No expiration date set for backup, please indicate how many days old"
	return 1
    fi
    notice "Backup of all read mails older than $expire days"
    oldread=`find $src/cur -type f | wc -l`
    oldunread=`find $src/new -type f | wc -l`

    newread=`find $src/cur -type f -mtime +$expire | wc -l`
    newunread=`find $src/new -type f -mtime +$expire | wc -l`

    act "from: (${oldread}/${oldunread} read/unread) maildir $src"
    if [ $newunread != 0 ]; then # use some highlight to signal long due unread
	act "to:   ($fg[red]${newread}/${newunread} read/unread$fg[white]) maildir $fg_bold[white]$dst$fg_no_bold[white]"
    else
	act "to:   (${newread}/${newunread} read/unread) maildir $dst"
    fi

    if [ $DRYRUN = 1 ]; then return 0; fi

    find $src/cur -mtime +$expire -type f -exec mv {} $dst/cur/ \;
    find $src/new -mtime +$expire -type f -exec mv {} $dst/new/ \;

    notice "Operation completed, current maildir sizes:"
    du -hs $src $dst
}

rmdupes() {
    tmp=$TMPDIR/$datestamp.rmdupes.$RANDOM
    newlock $tmp
    for folder in ${=PARAM}; do
	{ test ! -r $folder } && { folder=$MAILDIRS/$folder }
	{ test ! -r $folder } && { error "Maildir not found: $folder"; continue }
	notice "Removing duplicates in $folder"
	c=0
	for i in `find ${folder} -type f`; do
	    # 5MB should be enough ehre?
	    formail -D 5000000  $tmp <$i \
		&& rm $i && c=`expr $c + 1`
	done
    done
    unlink $tmp
    notice "$c duplicates found and deleted"
}

merge() {
    src=${PARAM[1]}
    dst=${PARAM[2]}
    if ! [ -r ${src}/cur ]; then
	error "No source maildir found in $src"
	return 1
    fi
    if ! [ -r ${dst}/cur ]; then
	error "No destination maildir found in $dst"
	return 1
    fi
    notice "Merging maildir ${src} into ${dst}"
    c=0
    for i in `find ${src}/cur -type f`; do mv $i ${dst}/cur/; c=`expr $c + 1`; done
    for i in `find ${src}/new -type f`; do mv $i ${dst}/new/; c=`expr $c + 1`; done
    for i in `find ${src}/tmp -type f`; do mv $i ${src}/tmp/; c=`expr $c + 1`; done
    act "$c mails succesfully moved."
    rmdupes ${dst}
    notice "Operation completed, you can now safely remove ${src}"
}

# re-sort all maildir through the procmail filters
# it can create duplicates, up to the user to rmdupes
filter() {

    update # update all filters

	# archive old procmail log
    if [ -r $WORKDIR/log/procmail.log ]; then
	newlock $WORKDIR/log/procmail-${datestamp}.log
	cat $WORKDIR/log/procmail.log \
	    >> $WORKDIR/log/procmail-${datestamp}.log
	rm -f $WORKDIR/log/procmail.log
	unlock $WORKDIR/log/procmail-${datestamp}.log
    fi

    for folder in ${=PARAM}; do
	typeset -al fall
	{ test ! -r $folder } && { folder=$MAILDIRS/$folder }
	{ test ! -r $folder } && { error "Maildir not found: $folder"; return 1 }
	notice "Filtering folder $folder"
	# first index current state
	for m in `find $folder -type f`; do fall+=($m); done
	# then process it, this way ignoring new mails send to same folder
	for n in ${=fall}; do
	    cat $n | procmail -m $PROCMAILDIR/rc
	done
	unset fall
    done

    total=`mailstat -k $WORKDIR/log/procmail.log | tail -n1 | awk '{print $2}'`
    briefing=`mailstat -kt $WORKDIR/log/procmail.log |awk '!/procmail/ { print "    " $2 "\t" $3 }'|sort -nr`
    echo "${briefing}"
}

# opens and closes a ramdisk for temporary files
# users can do this explicitly between session to speed up operations
ramdisk() {
    case $OS in
	GNU)
	    # TODO
	    # not so urgent, since usually /dev/shm is mounted and writable
	    ;;
	MAC)
	    case ${PARAM[1]} in
		open)
		    mount | grep 'JaroTmp' > /dev/null
		    { test $? = 0 } && {
			error "A Jaro Mail ramdisk is already open"
			return 1 }
		    # 2048 is a megabyte here
		    devsize=$((1024*2*10))
		    devname=`hdid -nomount ram://${devsize}`
		    act "Mounting 10MB ramdisk: $devname"
		    diskutil eraseVolume HFS+ JaroTmp `basename $devname` > /dev/null
		    { test $? != 0 } && {
			error "Error initializing ramdisk"
			hdiutil detach `basename $devname`
			return 1 }
		    notice "Operation successful, ramdisk ready on /Volume/JaroTmp"
		    TMPRAM=1
		    ;;
		close)
		    devname=`mount | awk '/JaroTmp/ {print $1}'`
		    { test "$devname" = "" } && {
			error "No ramdisk seems to be open"
			return 1 }
		    act "Unmounting ramdisk: $devname"
		    diskutil unmount /Volumes/JaroTmp > /dev/null
		    hdiutil detach `basename $devname` > /dev/null
		    notice "Ramdisk succesfully detached"
		    TMPRAM=0
		    ;;
	    esac
	    ;;
    esac
}
######################

usage() {
    cat <<EOF
Jaro Mail $VERSION - your humble and faithful electronic postman

 Copyright (C) 2010-2012 Dyne.org Foundation, License GNU GPL v3+
 This is free software: you are free to change and redistribute it
 The latest Jaro Mail sourcecode is on <http://jaromail.dyne.org>

Synopsis: jaro [options] [command] [command-options]

Main commands:

 fetch  download unread emails from [account]
 send   send all mails queued in the outbox
 peek   look into the [account] mailbox without downloading

Options:

 -a     use a particular account instead of default (keyword)
 -l     whitelist or blacklist to use with learn/query/forget
 -h     print this help
 -v     version information for this tool
 -q     run quietly without printing informations
 -n     dry run, show operations without executing them
 -D     print debugging information at runtime

Maintenance commands:

 passwd   reset password for the account in use

 update   refresh configurations
 queue    add a mail into outbox

 addr     look for a matching address in list
 query    read mail from stdin, return 0 if known to list
 learn    learn addresses from mails piped in stdin
 forget   remove addresses found in mails piped in stdin

 backup   move all mails older than N days from a maildir to another
 rmdupes  remove all duplicate mails into a maildir
 merge    merge a maildir into another, removing all duplicates

Please report bugs on <http://bugs.dyne.org>.
EOF
}

# TODO: For more informations on Jaro Mail read the manual: man jaro

main()
    {
    local -A subcommands_opts
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
    #              DON'T DO IT!
    #     There are two reasons for that:
    #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(a: -account=a l: -list=l q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n)
    subcommands_opts[__default]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]=""
    subcommands_opts[send]=""
    subcommands_opts[peek]=""
    subcommands_opts[update]=""
    subcommands_opts[stats]=""

    subcommands_opts[addr]=""
    subcommands_opts[query]=""
    subcommands_opts[learn]=""
    subcommands_opts[forget]=""
    subcommands_opts[list]=""

    subcommands_opts[edit]=""

    subcommands_opts[backup]=""
    subcommands_opts[rmdupes]=""
    subcommands_opts[merge]=""
    subcommands_opts[filter]=""

    subcommands_opts[passwd]=""
    subcommands_opts[cert]=""

    subcommands_opts[ramdisk]=""
    subcommands_opts[source]=""

#    subcommands_opts[mount]=${subcommands_opts[open]}
#    subcommands_opts[create]="s: -size=s -ignore-swap k: -key=k"
    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
	for opt in ${=optspec}; do
	    every_opts+=${opt}
	done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
	subcommand="__default"
    fi

# QUAA
    if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then
 # unknown command, pass it to autostart
	func "unknown command, autostart: $@"
	autostart ${@}
	exitcode=$?
	{ test $exitcode != 0 } && {
		error "command \"$subcommand\" not recognized"
		act "try -h for help"
		CLEANEXIT=0
	}
    	return $exitcode
    fi

    argv=(${oldstar})
    unset oldstar

    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
	zparseopts -M -E -D -Aopts ${cmd_opts}
	if [[ $? != 0 ]]; then
	    error "Some error occurred during option processing."
	    exitcode=1
	    return 1
	fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
    for arg in $*; do
	if [[ $arg == '--' || $arg == '-' ]]; then
	    ok=1
	    continue #it shouldnt be appended to PARAM
	elif [[ $arg[1] == '-'  ]]; then
	    if [[ $ok == 0 ]]; then
		error "unrecognized option $arg"
		exitcode=1
		return 1
	    fi
	fi
	PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
	PARAM[1]=()
	shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then
	cat $JAROMAILEXEC | awk '/^#/ {print $0 } !/^#/ {exit}'
	echo
    fi
    if option_is_set -a; then account=`option_value -a`; fi
    if option_is_set -l; then list=`option_value -l`; fi
    { option_is_set -h } && { CLEANEXIT=0; usage; return 0 }
    { option_is_set -v } && { CLEANEXIT=0;
	cat $JAROMAILEXEC | awk 'BEGIN { v=1 } !/^#/ { exit }'; return 0 }
    if option_is_set -q; then QUIET=1; fi
    if option_is_set -D; then func "Debug messages ON"; DEBUG=1; fi
    if option_is_set -n; then act "Dry run, show operations without executing them."; DRYRUN=1; fi

    case "$subcommand" in
	queue)   queue ${PARAM} ;;
	fetch)   fetch ${PARAM} ;;
	send)    send ${PARAM} ;;
	peek)    peek ${PARAM} ;;

	update)  update ;;

	stats)   CLEANEXIT=0; stats ;;
	addr)    CLEANEXIT=0; address ${PARAM} ;;
	query)   CLEANEXIT=0; query ${PARAM} ;;
	learn)   CLEANEXIT=0; learn ${PARAM} ;;
	forget)  CLEANEXIT=0; forget ${PARAM} ;;
	list)    CLEANEXIT=0; list_addresses ${PARAM} ;;

	edit)    CLEANEXIT=0; editor ${PARAM} ;;

	backup)  backup ${PARAM} ;;
	rmdupes) rmdupes ${PARAM} ;;
	merge)   merge ${PARAM} ;;
	filter)  filter ${PARAM} ;;

	passwd)  read_account;
	    { test $? = 0 } && { new_password ${PARAM} }
	    ;;
	cert)    cert ${PARAM} ;;

	ramdisk) ramdisk ${PARAM} ;;

	'source')   CLEANEXIT=0; return 0 ;;
	__default)  func "no command provided"
	    autostart ${PARAM}
	    exitcode=$?
	    ;;
	*) # unknown command, pass it to autostart
	    func "unknown command, remote check"
	    autostart ${PARAM}
	    exitcode=$?
	    { $exitcode != 0 } && {
		error "command \"$subcommand\" not recognized"
		act "try -h for help"
		CLEANEXIT=0
	    }
	    ;;
    esac
    return 0
}

check_bin
main $@
if [ $CLEANEXIT = 1 ]; then cleanexit; fi
return $exitcode
