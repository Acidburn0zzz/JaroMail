#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=0.1
DATE=May/2012
JAROMAILEXEC=$0
typeset -a OLDARGS
for arg in ${argv}; do OLDARGS+=($arg); done

##########################
# declare global variables

QUIET=0
DEBUG=1



# which command to use when creating dirs
mkdir="`which mkdir` -m 700 -p"
# date stamp
datestamp=`date '+%d%b%y'`

##########################


PARAM=()
typeset -A global_opts
typeset -A opts

# global variables for accounts
typeset -h name login host protocol port password auth folders accountopt

# global variable for exit code
typeset exitcode
exitcode=0

autoload colors; colors

# standard output message routines
# it's always useful to wrap them, in case we change behaviour later
notice() { if [[ $QUIET == 0 ]]; then print "$fg_bold[green][*]$fg_no_bold[white] $1" >&2; fi }
error()  { if [[ $QUIET == 0 ]]; then print "$fg[red][!]$fg[white] $1" >&2; fi }
func()   { if [[ $DEBUG == 1 ]]; then print "$fg[blue][D]$fg[white] $1" >&2; fi }
act()    {
    if [[ $QUIET == 0 ]]; then
	if [ "$1" = "-n" ]; then
	    print -n "$fg_bold[white] . $fg_no_bold[white] $2" >&2;
	else
	    print "$fg_bold[white] . $fg_no_bold[white] $1" >&2;
	fi
    fi
}


# what operating system are we in? use os_detect()
# simplifying modes of operation: GNU or MAC
if [ "$1" != "-q" ]; then # honor quiet flag
    case $(uname) in
	Linux) OS=GNU
	    notice "Jaro Mail v$VERSION running on GNU/Linux"	;;
	
	Darwin) OS=MAC
	    notice "Jaro Mail v$VERSION running on Mac/OSX"	;;
	
	*) OS=GNU # default
	    error "Running on an unknown operating system, assuming GNU" ;;
    esac
fi

if [ -z $MAILDIRS ]; then
    # check if we are inside the directory
    if [ -r jaro/bin/jaro ]; then
	MAILDIRS=`pwd`
    else # else use default
	MAILDIRS=$HOME/Mail
    fi
fi


# default working dir
WORKDIR=$MAILDIRS/jaro

${=mkdir} $MAILDIRS
${=mkdir} $WORKDIR

# make sure the directory is private
chmod 700 $WORKDIR

# make sure we have a temp and cache dir
${=mkdir} "$WORKDIR/tmp"
${=mkdir} "$WORKDIR/cache"
${=mkdir} "$WORKDIR/log"
${=mkdir} "$WORKDIR/certs"

PROCMAILDIR=$WORKDIR/.procmail
MUTTDIR=$WORKDIR/.mutt

cleanexit() {
    for f in `ls $WORKDIR/tmp/`; do
	${=rm} $WORKDIR/tmp/$f
    done
    unset typeset -h name login host protocol port password auth folders accountopt
}
# make sure tmp is wiped from sensitive data in case of sigINT
TRAPINT() {
	error "Caught signal, aborting operations."
	cleanexit
	if [ "$DEBUG" = "1" ]; then
	    return 1
	else
	    exit 1
	fi
}

# we use pinentry
# comes from gpg project and is secure
# it also conveniently uses the right toolkit
pin_entry() {
    	cat <<EOF | pinentry 2>/dev/null | awk '/^D / { sub(/^D /, ""); print }'
OPTION ttyname=$TTY
OPTION lc-ctype=$LANG
SETTITLE Type your password
SETDESC Type the password for $1 @ $2
SETPROMPT Password:
GETPIN
EOF
}


check_bin() {
    # check for required programs
    for req in pinentry fetchmail procmail; do
	which $req >/dev/null || die "Cannot find $req.  Please install it." 1
    done

    # which wipe command to use
    which wipe > /dev/null
    if [ $? = 0 ]; then rm="wipe -f -s -q -R /dev/urandom"
    else which srm > /dev/null
	if [ $? = 0 ]; then rm="srm -m"
	else rm="rm -f"; fi
    fi
}

# retrieve a password for user @ domain
# put it in variable password
# up to the caller to unset it after use
ask_password() {
    case $OS in
	MAC)
	    func "Looking for password in keyring: $1 @ $2"
	    security find-internet-password -a $1 -s $2 > /dev/null
	    if [ $? != 0 ]; then # its a new password
		password=`pin_entry $1 @ $2`
		act "New password set for $1 @ $2"
		security add-internet-password -a $1 -s $2 -w "${password}"
	    else
		act "Using saved password for $1 @ $2"        
		password=`security find-internet-password -a $1 -s $2 -g \
		    2>&1| awk '/^password:/ { print $2 }' | sed -e 's/"//g'`
	    fi
	    return 0
	    ;;
	GNU)
	    password=`pin_entry $login $host`
	    if [ "$password" != "" ]; then
		return 0
	    else
		return 1
	    fi
	    ;;
	*)
	    error "Unknown system, can't figure out how to handle passwords"
	    return 1
    esac
}

switch_identity() {
    if [ "$name" != "" ]; then
	act "switch to identity: $name <$login>"
	rm -f $MUTTDIR/identity
	cat <<EOF > $MUTTDIR/identity
set hostname = $host
set realname = "$name"
set from = "$name <$login>"
EOF
    else
	error "No identity found, left blank."
	touch $MUTTDIR/identity	
    fi
}


option_is_set() {
    #First argument, the option (something like "-s")
    #Second (optional) argument: if it's "out", command will print it out 'set'/'unset'
    #                       This is useful for if conditions
    #Return 0 if is set, 1 otherwise
    [[ -n ${(k)opts[$1]} ]];
    r=$?
    if [[ $2 == out ]]; then
        if [[ $r == 0 ]]; then
            echo 'set'
        else
            echo 'unset'
        fi
    fi
    return $r;
}
option_value() {
    #First argument, the option (something like "-s")
    <<< ${opts[$1]}
}
maildirmake() {

    if [ -z $1 ]; then
	error "internal error: missing argument for maildirmake"
	return
    fi

    if [ -r $1 ]; then
	func "maildir exists: $1"
	return
    fi

    ${=mkdir} ${1}/cur
    ${=mkdir} ${1}/new
    ${=mkdir} ${1}/tmp

}
# arg 1 : account name, es: imap.gmail
read_account() {
    adir=$WORKDIR/Accounts
    acct=$1
    type="`echo $1|cut -d. -f1`"
    # find the file
    if [ -r $adir/$acct.txt ]; then
	acct=$adir/$acct.txt
    elif [ -r $adir/$acct ]; then  # try without .txt
	acct=$adir/$acct
    else
	error "account $acct not found in $adir"
	return 1
    fi
    atmp=$WORKDIR/tmp/$1
    case $type in
	imap|smtp)
	    ttmp=`cat $acct | awk '
    /^#/ { next }
    /^name/ { printf "name=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^email/ { printf "email=\"%s\";", $2 }
    /^host/ { printf "host=\"%s\";", $2 }
    /^login/ { printf "login=\"%s\";", $2 }
    /^transport/ { printf "transport=\"%s\";", $2 }
    /^port/ { printf "port=\"%s\";", $2 }
    /^password/ { printf "password=\"%s\";", $2 }
    /^auth/ { printf "auth=\"%s\";", $2 }
    /^cert/ { printf "cert=\"%s\";", $2 }
    /^options/ { printf "accountopt=\""; for(i=2;i<=NF;i++) printf "%s ", $i; printf "\";" }
    /^folders/ { printf "folders=\"%s\";", $2 }
    '`
	    eval "$ttmp"
	    # check required fields
	    { test -z $host }  && { error "Field missing in account $acct: host"; return 1 }
	    { test -z $login } && { error "Field missing in account $acct: login"; return 1 }
	    # fill in defaults
	    { test -z $name }       && { name="$type" }
	    { test -z $email }       && { email="$login" }
	    { test -z $transport }  && { transport=ssl }
	    { test -z $port }       && { port=993 }
	    { test -z $auth }       && { auth=plain }
	    { test -z $cert }       && { cert=ignore }
	    { test -z $accountopt } && { accountopt=keep }
	    # cert and password can be missing

	    func "type: $type"
	    func "name: $name"
	    func "email: $email"	    
	    func "host: $host"
	    func "login: $login"
	    func "trans: $transport"
	    func "port: $port"
	    func "cert: $cert"
	    func "auth: $auth"
	    func "options: $accountopt"
	    func "folders: $folder"
	    ;;
	*)
	    error "Account type \"$type\" not recognized."
	    return 1
	    ;;
    esac
    return 0
}
# read a default account
# arg: "in" or "out"
# meaning an account to receive or send emails
read_default_account() {
    adir=$WORKDIR/Accounts
    typeset -al all
    if [ -z $1 ]; then
	error "Error: read_default_account called without argument"
	return 1
    fi
    case $1 in
	"in")
	    if [ -r $adir/imap.default ]; then
		read_account imap.default
		return $?
	    else
		for a in `find $adir -name "imap*"`; do all+=($a); done
		for a in `find $adir -name "pop*"`; do all+=($a); done
		if [ ${#all} != 0 ]; then
		    read_account `basename ${all[1]}` # take the first found
		    return $?
		else
		    error "No accounts configured, look in $WORKDIR/Accounts"
		fi
	    fi
	    ;;
	"out")
	    if [ -r $adir/smtp.default ]; then
		read_account smtp.default
		return $?
	    else
		for a in `find $adir -name "smtp*"`; do all+=($a); done
		read_account `basename ${all[1]}` # take the first found
		return $?
	    fi
	    ;;
    esac
    return 1
}

queue() {
    local base;
    local tmp;
    local mailfile;
    local msmtpfile;

    # add mails to the sendout queue
    ${=mkdir} $MAILDIRS/outbox
    cd $MAILDIRS/outbox || return 1
    notice "Adding mail to the outbox queue"
    # Create new unique filenames of the form
    # MAILFILE:  ccyy-mm-dd-hh.mm.ss[-x].mail
    # MSMTPFILE: ccyy-mm-dd-hh.mm.ss[-x].msmtp
    # where x is a consecutive number only appended if you send more than one 
    # mail per second.
    base="`date +%Y-%m-%d-%H.%M.%S`"
    func "[$base] queue called with params: ${PARAM[@]}"

    if [ -f "$base.mail" -o -f "$base.msmtp" ]; then
	tmp="$base"
	i=1
	while [ -f "$tmp-$i.mail" -o -f "$tmp-$i.msmtp" ]; do
		i=`expr $i + 1`
	done
	base="$base-$i"
    fi
    mailfile="$base.mail"
    msmtpfile="$base.msmtp"
    # Write command line to $MSMTPFILE
    echo "$@" > "$msmtpfile"
    # Write the mail to $MAILFILE
    cat > "$mailfile"
    cd -
    return 0
}

######
# CERT
# downloads and/or installs certificates
cert() {
    if [ -z $1 ]; then
	error "Certificate handler called without an argument"
	return 1;
    fi

    certificate="$1"

    case $certificate in
	gmail)
	    cc=Equifax_Secure_Certificate_Authority
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then
		
		curl -o $WORKDIR/certs/${cc}.pem \
		    "https://www.geotrust.com/resources/root_certificates/certificates/${cc}.cer"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem -fingerprint \
		    -subject -issuer -serial -hash -noout
	    fi
	    ;;
	dyne|autistici|freaknet)
	    cc=Autistici_Certificate_Authority
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then
		curl -o $WORKDIR/certs/${cc}.pem \
		    "http://ca.autistici.org/ca.pem"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem \
		    -fingerprint -subject -issuer -serial -hash -noout
	    fi
	    ;;
	riseup)
	    cc=RiseupCA
	    if ! [ -r $WORKDIR/certs/${cc}.pem ]; then
		curl -o $WORKDIR/certs/${cc}.pem "https://help.riseup.net/assets/43052/RiseupCA.pem"
		openssl x509 -in \
		    $WORKDIR/certs/${cc}.pem \
		    -fingerprint -subject -issuer -serial -hash -noout
	    fi
	    ;;
	*)
	    cc="`basename $certificate`"
	    curl -o "$WORKDIR/certs/${cc}" "$certificate"
	    if [ $? != 0 ]; then
		error "Error downloading certificate: $certificate"
		return 1
	    fi
	    openssl x509 -in \
		"$WORKDIR/certs/${cc}" \
		-fingerprint -subject -issuer -serial -hash -noout
	    ;;
    esac
    act "refreshing certificates"
    c_rehash $WORKDIR/certs > /dev/null
    if [ $? != 0 ]; then
	error "Error refreshing certificates in $WORKDIR/certs"
	c_rehash $WORKDIR/certs
    fi
    return 0
}

###########
# FETCHMAIL
fetch() {
    adir=$WORKDIR/Accounts
    acct=$1
    typeset -al all
    if [ -z $acct ]; then # fetch all accounts
	for a in `find $adir -name "imap*"`; do all+=($a); done
	for a in `find $adir -name "pop*"`; do all+=($a); done
    else
	# fetch only one account
	for a in `find $adir -name "$acct*"`; do all+=($a); done
    fi
    if ! [ -r $PROCMAILDIR/rc ]; then
	act "updating procmail configuration"
	update
    fi
    for a in ${all}; do
	read_account `basename $a`
	if [ $? != 0 ]; then
	    error "Account configuration not found, or broken. Aborting operation."
	    return 1
	fi
	notice "Fetching mails from $name"
	touch $WORKDIR/tmp/$host.fetch
	chmod 600 $WORKDIR/tmp/$host.fetch
	ask_password $login $host
	if [ $? != 0 ]; then
	    error "Error retrieving password for $login on $host"
	    unset password all
	    return 1
	fi

	cat <<EOF > $WORKDIR/tmp/$host.fetch
poll $host with proto IMAP user "$login" there with password "$password"
EOF
	unset password

	if ! [ -z $accountopt ]; then # add option configuration
	    echo "${accountopt}" >> $WORKDIR/tmp/$host.fetch; fi

	if ! [ -z $folders ]; then # add folder configuration
	    echo "folder ${folders}" >> $WORKDIR/tmp/$host.fetch; fi

	cat <<EOF >> $WORKDIR/tmp/$host.fetch
ssl warnings 3600 and wants mda "procmail -m $PROCMAILDIR/rc"
EOF
	if [ "$cert" = "check" ]; then
	    cat <<EOF >> $WORKDIR/tmp/$host.fetch
sslcertck sslcertpath '$WORKDIR/certs'
EOF
	fi
	cat <<EOF >> $WORKDIR/tmp/$host.fetch
antispam 571 550 501 554
EOF

	# try login without doing anything
	fetchmail -c -f $WORKDIR/tmp/$host.fetch
	# examine result
	case $? in
	    1) 
		notice "No mails for $name"
		${=rm} $WORKDIR/tmp/$host.fetch
		return 1
		;;
	    2)
		error "Invalid or unknown certificate for $host"
		${=rm} $WORKDIR/tmp/$host.fetch
		return 1
		;;
	    3)
		error "Invalid password for user $login at $host"
		${=rm} $WORKDIR/tmp/$host.fetch
		return 1
		;;
	    *) ;;
	esac

	# archive old procmail log
	if [ -r $WORKDIR/log/procmail.log ]; then
	    touch $WORKDIR/log/procmail-${datestamp}.log
	    chmod 700 $WORKDIR/log/procmail-${datestamp}.log
	    cat $WORKDIR/log/procmail.log \
		>> $WORKDIR/log/procmail-${datestamp}.log
	    rm -f $WORKDIR/log/procmail.log
	fi
	act "please wait while downloading mails..."

	( sleep 2; ${=rm} $WORKDIR/tmp/$host.fetch ) &
	fetchmail -f $WORKDIR/tmp/$host.fetch
	
	total=`mailstat -k $WORKDIR/log/procmail.log | tail -n1 | awk '{print $2}'`
	briefing=`mailstat -kt $WORKDIR/log/procmail.log |awk '!/procmail/ { print " .  " $2 "\t" $3 }'|sort -nr`
	notice "$total emails fetched"
	echo "${briefing}"
    done
    return 0
}

######
# SEND
# this function should send all mails in outbox
send() {
    adir=$WORKDIR/Accounts
    acct=$1
    typeset -al all

    # list mails to send
    mailnum=`ls ${MAILDIRS}/outbox | grep 'mail$' | wc -l`
    mailnum=${mailnum// /} # trim whitespace
    if [ "$mailnum" = "0" ]; then
        act "Outbox is empty, no mails to send."
        return 0
    fi

    if [ -z $acct ]; then
	if [ -r $adir/smtp.default ]; then
	    all+=($adir/smtp.default) # use the default account
	else # else will use the first one
	    for a in `find $adir -name "smtp*"`; do all+=($a); done
	fi
    else # or if specified, use a particular account
	for a in `find $adir -name "smtp*$acct*"`; do all+=($a); done
    fi
    read_account `basename ${all[1]}`

    notice "Sending out ${mailnum} mails via `basename ${all[1]}`"
 
    # defaults
    [ -z $auth ] && auth=plain
    [ -z $port ] && port=25
    
    touch $WORKDIR/tmp/$host.send
    chmod 600 $WORKDIR/tmp/$host.send
    ask_password $login $host
    cat <<EOF > $WORKDIR/tmp/$host.send
account default
from ${name}
user ${login}
host ${host}
port ${port}
tls on
tls_starttls on
tls_certcheck off
logfile ${WORKDIR}/log/msmtp.log
auth ${auth}
password ${password}
EOF
    unset password

    for mail in `find $MAILDIRS/outbox -name "*.mail"`; do
       act "`cat ${mail} | grep '^To:'`"
       smtp=`echo ${mail} | sed -e 's/mail/msmtp/'`
       msmtp -C $WORKDIR/tmp/$host.send "`cat ${smtp}`" < "${mail}"
       if [ $? != 0 ]; then
           error "Error sending mail, skipped"
       else
	   act "Mail sent succesfully"
	   ${=rm} ${mail} ${smtp}
       fi
    done
    cd -
    ${=rm} $WORKDIR/tmp/$host.send
    return 0
}

######
# PEEK
# this function will open the MTA to the imap server without fetching mails locally
peek() {
    if [ -z $1 ]; then
	read_default_account in
    else
	adir=$WORKDIR/Accounts
	acct=$1
	typeset -al all
	for a in `find $adir -name "imap.$acct*"`; do all+=($a); done
	read_account `basename ${all[1]}`
    fi
    notice "Peek into remote imap account $name"
    switch_identity
    case $transport in
	ssl) iproto="imaps" ;;
	plain) iproto="imap" ;;
    esac
    # escape at sign in login
    ilogin=`echo $login | sed 's/@/\\@/'`
    mutt -F $MUTTDIR/rc -f ${iproto}://${ilogin}@${host}
    # TODO automatic input of password in mutt
    return $?
}

update() {
    notice "Updating all configurations and filters"
    # this function should:
    # parse all filters
    # generate procmailrc
    # generate muttrc
    # backup what's too old in the maildirs
    # ...
    
    # debug configuration
    func "MAILDIRS:    $MAILDIRS"
    func "WORKDIR:     $WORKDIR"
    func "MUTTDIR:     $MUTTDIR"
    func "PROCMAILDIR: $PROCMAILDIR"

    # make sure maildirs where to put mails exist
    ${=mkdir} $MAILDIRS
    maildirmake $MAILDIRS/known
    maildirmake $MAILDIRS/sent
    maildirmake $MAILDIRS/priv
    maildirmake $MAILDIRS/postponed
    maildirmake $MAILDIRS/unsorted
    ${=mkdir} $MAILDIRS/outbox
    
    ######
    # MUTT
    ${=mkdir} $MUTTDIR
    rm -f $MUTTDIR/rc
    cat<<EOF > $MUTTDIR/rc
# mutt config generated by Jaro Mail
unset use_domain
set folder = $MAILDIRS
set spoolfile = $MAILDIRS/known/
set record = $MAILDIRS/sent/
set postponed= $MAILDIRS/postponed/
set tmpdir = $WORKDIR/tmp
set query_command = "$WORKDIR/bin/jaro -q query '%s'"
set sendmail = "$WORKDIR/bin/jaro queue"
set header_cache= $WORKDIR/cache
set maildir_header_cache_verify=no
set editor = "$EDITOR"
set mailcap_path = "$WORKDIR/mailcap"

macro index,pager A "<pipe-message>$WORKDIR/bin/jaro -q learn" "add the sender address to lbdb"
macro index,pager + "<pipe-message>$WORKDIR/bin/jaro -q learn" "add the sender address to lbdb"

EOF

    if [ -r $MUTTDIR/general ]; then
	echo "# user tweaked configuration" >> $MUTTDIR/rc
	echo "source ${MUTTDIR}/general" >> $MUTTDIR/rc
    fi

cat <<EOF >> $MUTTDIR/rc
# mailboxes in order of priority
source $MUTTDIR/mboxes

# specific configuration files
# hardcoded path for now (TODO)
source $MUTTDIR/crypto
source $MUTTDIR/colors
source $MUTTDIR/formats
source $MUTTDIR/keybindings
source $MUTTDIR/identity
## end of Jaro Mail generated muttrc
####################################

EOF

    
    # just the header, will be completed later in procmail loop
    rm -f $MUTTDIR/mboxes
    echo -n "mailboxes +priv" > $MUTTDIR/mboxes

    # update identity with default
    read_default_account "in"
    switch_identity

    ##########
    # PROCMAIL
    act "generating procmail filters"
    ${=mkdir} $PROCMAILDIR
    rm -f $PROCMAILDIR/rc
    touch $PROCMAILDIR/rc
    cat<<EOF >> $PROCMAILDIR/rc
# procmail configuration file generated by Jaro Mail
MAILDIR=$MAILDIRS
JARO=$WORKDIR/bin/jaro
DEFAULT=unsorted/
VERBOSE=off
LOGFILE=$WORKDIR/log/procmail.log
SHELL       = /bin/sh       # VERY IMPORTANT
UMASK       = 007           # James Bond :-)
LINEBUF     = 8192          # avoid procmail choke

#  Using Procmail Module Library http://sf.net/projects/pm-lib
PMSRC  = $PROCMAILDIR
#  Load the central initial startup code.
INCLUDERC = \$PMSRC/pm-javar.rc
PF_DEST = ""			# clear these vars
PF_FROM = ""
# don't save multiple copies
PF_RECURSE = yes
:0
* ? test \$PMSRC/pf-chkto.rc
{
EOF

    #######
    echo "# filters generated from Accounts" >> $PROCMAILDIR/rc
    typeset -al accts
    for f in `cat $WORKDIR/Accounts/* | awk '/^email/ { print $2 }'`; do
	echo "ADDR=${f}\tDEST=priv/\tINCLUDERC=\$PMSRC/pf-chkto.rc"  >> $PROCMAILDIR/rc
	act "private account: <${f}>"
    done

    #######
    echo "# filters generated from Filters.txt" >> $PROCMAILDIR/rc
    
    for f in `cat $WORKDIR/Filters.txt | awk '/^#/ {next} /^./ { print $1 ";" $2 ";" $3 ";" $4 }'`; do
	header="${f[(ws:;:)1]}"
	address="${f[(ws:;:)2]}"
	action="${f[(ws:;:)3]}"
	destination="${f[(ws:;:)4]}"
	case $header in
	    to)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-chkto.rc" \
		    >> $PROCMAILDIR/rc
		act "messages to <${address}> in folder: ${destination}"
		;;
	    from)
		print "ADDR=${address}\tDEST=${destination}/\tINCLUDERC=\$PMSRC/pf-check.rc" \
		    >> $PROCMAILDIR/rc
		act "messages from <${address}> in folder: {$destination}"
		;;
	    *)
		error "unsupported filter: $header (skipped)"
		;;
	esac
	# MUTT (generate mailboxes priority this parser)
	echo  " \\" >> $MUTTDIR/mboxes
	echo -n " +${destination} " >> $MUTTDIR/mboxes
    done

    echo " \\" >> $MUTTDIR/mboxes
    echo " +unsorted" >> $MUTTDIR/mboxes
    uniq $MUTTDIR/mboxes > $WORKDIR/tmp/mboxes
    mv $WORKDIR/tmp/mboxes $MUTTDIR/mboxes
    rm -f $WORKDIR/tmp/mboxes

    cat <<EOF >> $PROCMAILDIR/rc
}

# save the mails
:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }

# if the sender is known (ldbd recognizes it) then put mail in high priority 'known'
:0 w:
* ? formail -x"From:" | head -n1 | tr 'A-Z' 'a-z' | sed 's/.*\W\([0-9a-z_.-]\+@[0-9a-z_.-]\+\).*/\1/' | xargs \$JARO -q query
known/

# if got here, go to unsorted

# save the mails
:0
* PF_DEST ?? .
* ? test \$PMSRC/pf-save.rc
{ INCLUDERC=\$PMSRC/pf-save.rc }

EOF
    return 0
} # end of update()


query() {
    if [ $QUIET = 1 ]; then
	${WORKDIR}/bin/lbdbq ${@} > /dev/null
	exitcode=$?
    else
	act -n "Query known address <${@}> in "
	${WORKDIR}/.lbdb/lbdbq ${@}
	exitcode=$?
    fi
}

learn() {
    if [ $QUIET = 1 ]; then
	${WORKDIR}/bin/lbdb-fetchaddr -a > /dev/null
	exitcode=$?
    else
	act "Learning new address from mail pipe in stdin"
	${WORKDIR}/bin/lbdb-fetchaddr -a
	exitcode=$?
    fi
}

usage() {
    cat <<EOF
Jaro Mail $VERSION - your humble and faithful electronic postman

 Copyright (C) 2010-2012 Dyne.org Foundation, License GNU GPL v3+
 This is free software: you are free to change and redistribute it
 The latest Tomb sourcecode is published on <http://tomb.dyne.org>

Syntact: jaro command [options] [account]

Commands:

 peek   look into the [account] mailbox without downloading
 fetch  download unread emails from [account]
 read   open mutt to read all local mailfolders
 send   send all mails queued in the outbox

Options:

 -h     print this help
 -v     version information for this tool
 -q     run quietly without printing informations
 -D     print debugging information at runtime

Internal commands:

 update refresh configurations
 queue  add into outbox
 query  query a name from addressbook
 learn  learn known addresses from mails piped in stdin


Please report bugs on <http://bugs.dyne.org>.
EOF
}

# TODO: For more informations on Jaro Mail read the manual: man jaro

main()
    {
    local -A subcommands_opts
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
    #              DON'T DO IT!
    #     There are two reasons for that:
    #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n)
    subcommands_opts[__default]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]=""
    subcommands_opts[send]=""
    subcommands_opts[read]=""
    subcommands_opts[compose]=""
    subcommands_opts[peek]=""    
    subcommands_opts[update]=""
    subcommands_opts[query]=""
    subcommands_opts[learn]=""
    subcommands_opts[source]=""
    subcommands_opts[cert]=""
#    subcommands_opts[mount]=${subcommands_opts[open]}
#    subcommands_opts[create]="s: -size=s -ignore-swap k: -key=k"
    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
        for opt in ${=optspec}; do
            every_opts+=${opt}
        done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
        subcommand="__default"
    fi
    if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then #there's no such subcommand
        error "Subcommand '$subcommand' doesn't exist"
        exitcode=1
	return 1
    fi
    argv=(${oldstar})
    unset oldstar

    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
        zparseopts -M -E -D -Aopts ${cmd_opts}
	if [[ $? != 0 ]]; then
	    error "Some error occurred during option processing."
            exitcode=1
	    return 1
	fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
    for arg in $*; do
	if [[ $arg == '--' || $arg == '-' ]]; then
	    ok=1
	    continue #it shouldnt be appended to PARAM
	elif [[ $arg[1] == '-'  ]]; then
	    if [[ $ok == 0 ]]; then
		error "unrecognized option $arg"
		exitcode=1
		return 1
	    fi
	fi
	PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
	PARAM[1]=()
	shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then act "Jaro Mail - $VERSION"; fi
    if option_is_set -h; then usage;  fi
    if option_is_set -q; then QUIET=1; fi
    if option_is_set -D; then func "Debug messages ON"; DEBUG=1; fi
        
    case "$subcommand" in
	queue) queue ${PARAM} ;;
	fetch) fetch ${PARAM} ;;
	send) send ${PARAM} ;;
	peek) peek ${PARAM} ;;
	read) mutt -F $MUTTDIR/rc ;;
	cert) cert ${PARAM} ;;
	compose) mutt -F $MUTTDIR/rc ${PARAM} ;;

	update) update ;;

	query) query ${PARAM} ;;
	learn) learn ${PARAM} ;;

	'source')   return 0 ;;
	__default) ;;
	*) error "command \"$subcommand\" not recognized"
	    act "try -h for help"
	    return 1
	    ;;
    esac
    return 0
}

check_bin
main $@
cleanexit
return $exitcode
