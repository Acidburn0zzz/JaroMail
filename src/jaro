#!/usr/bin/env zsh
#
# Jaro Mail, your humble and faithful electronic postman
#
# a tool to easily and privately handle your e-mail communication
#
# Copyleft (C) 2010-2012 Denis Roio <jaromil@dyne.org>
#
# This source  code is free  software; you can redistribute  it and/or
# modify it under the terms of  the GNU Public License as published by
# the Free  Software Foundation; either  version 3 of the  License, or
# (at your option) any later version.
#
# This source code is distributed in  the hope that it will be useful,
# but  WITHOUT ANY  WARRANTY;  without even  the  implied warranty  of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# Please refer to the GNU Public License for more details.
#
# You should have received a copy of the GNU Public License along with
# this source code; if not, write to:
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

VERSION=0.9
DATE=Jun/2012
JAROMAILEXEC=$0
typeset -a OLDARGS
for arg in ${argv}; do OLDARGS+=($arg); done

##########################
# declare global variables

QUIET=0
DEBUG=0
DRYRUN=0
CLEANEXIT=1
CALLMUTT=1
TMPRAM=0

# which command to use when creating dirs
mkdir="`which mkdir` -m 700 -p"
# date stamp
datestamp=`date '+%d%b%y'`
##########################

# # # # SQL
# command
SQL=sqlite3


PARAM=()
typeset -A global_opts
typeset -A opts

# global variable for account selection
typeset -h account
account=default
typeset -h list
list=whitelist

# global variables for accounts
typeset -h name login host protocol port password auth folders accountopt

# global array for maildirs (filled by list_maildirs)
typeset -al maildirs
    
# global variable for exit code
typeset exitcode
exitcode=0

autoload colors; colors

# standard output message routines
# it's always useful to wrap them, in case we change behaviour later
notice() { if [[ $QUIET == 0 ]]; then print "$fg_bold[green][*]$fg_no_bold[default] $1" >&2; fi }
error()  { if [[ $QUIET == 0 ]]; then print "$fg[red][!]$fg[default] $1" >&2; fi }
func()   { if [[ $DEBUG == 1 ]]; then print "$fg[blue][D]$fg[default] $1" >&2; fi }
act()    {
    if [[ $QUIET == 0 ]]; then
	if [ "$1" = "-n" ]; then
	    print -n "$fg_bold[white] . $fg_no_bold[default] $2" >&2;
	else
	    print "$fg_bold[white] . $fg_no_bold[default] $1" >&2;
	fi
    fi
}

# honor quiet flag as early as possible
echo "${@}" | grep '\-q' > /dev/null # silent
if [ "$?" = 0 ]; then QUIET=1; fi


# what operating system are we in? use os_detect()
# simplifying modes of operation: GNU or MAC
case $(uname) in
    Linux) OS=GNU
	notice "Jaro Mail v$VERSION running on GNU/Linux"	;;

    Darwin) OS=MAC
	notice "Jaro Mail v$VERSION running on Mac/OSX"	;;

    *) OS=GNU # default
	error "Running on an unknown operating system, assuming GNU" ;;
esac

if [ -z $MAILDIRS ]; then
    # check if we are inside the directory
    if [ -r jaro/bin/jaro ]; then
	MAILDIRS=`pwd`
    else # else use default
	MAILDIRS=$HOME/Mail
    fi
fi


# default working dir
WORKDIR=$MAILDIRS/jaro

${=mkdir} $MAILDIRS
${=mkdir} $WORKDIR

# make sure the directory is private
chmod 700 $WORKDIR

PATH=$WORKDIR/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/opt/local/bin

# load our ZLibs
. $WORKDIR/zlibs/accounts
. $WORKDIR/zlibs/addressbook
. $WORKDIR/zlibs/cmdline
. $WORKDIR/zlibs/email
. $WORKDIR/zlibs/helpers
. $WORKDIR/zlibs/locking
. $WORKDIR/zlibs/maildirs
. $WORKDIR/zlibs/password
. $WORKDIR/zlibs/search
. $WORKDIR/zlibs/stats

# temporary directory
TMPDIR=$WORKDIR/tmp
case $OS in
    GNU)
	touch /dev/shm/jaromail.test.tmp > /dev/null
	{ test $? = 0 } && {
	# we can use volatile ram
	    rm -f /dev/shm/jaromail.test.tmp
	    TMPDIR=/dev/shm/jaromail.$USER
	    TMPRAM=1
	}
	;;
    MAC)
	mount | grep 'JaroTmp' > /dev/null
	{ test $? = 0 } && {
	    # our RAM temp directory is active
	    TMPDIR=/Volumes/JaroTmp/jaromail.$USER
	    TMPRAM=1
	}
	;;
esac

{ test $TMPRAM = 1 } && {
    act "Using temporary directory in volatile RAM" }


# make sure we have a temp and cache dir
${=mkdir} "$TMPDIR"
{ test $? != 0 } && {
    error "Cannot create temporary directory: $TMPDIR"
    return 1 }

${=mkdir} "$WORKDIR/cache"
${=mkdir} "$WORKDIR/log"
${=mkdir} "$WORKDIR/certs"

PROCMAILDIR=$WORKDIR/.procmail
MUTTDIR=$WORKDIR/.mutt


# use gnome-keyring for passwords on GNU systems
GNOMEKEY=0
ps ax | grep '[g]nome-keyring-daemon' > /dev/null
{ test $? = 0 } && {
    which jaro-gnome-keyring > /dev/null
    { test $? = 0 } && { GNOMEKEY=1 }
}


cleanexit() {
    func "Clean exit procedures"
    # while ( ps ax | grep '[s]rm' > /dev/null
    # 	test $? = 0 ); do sleep 1; done

    # for f in `ls $TMPDIR/ | grep -v '.lock$'`; do
    # 	{ test ! -r $TMPDIR/$f.lock } && { unlink $TMPDIR/$f }
    # done

#    { test $TMPRAM = 1 } && { rmdir $TMPDIR }
    unset typeset -h name login host protocol port password auth folders accountopt
}
# make sure tmp is wiped from sensitive data in case of sigINT
TRAPINT() {
	error "Caught signal, aborting operations."
	{ test $CLEANEXIT = 1 } && { cleanexit }
	error "Forced removal of locks"
	{ test $TMPDIR } && {
	    for l in `find $TMPDIR/`; do
		${=rm} $l; done
	}
	if [ "$DEBUG" = "1" ]; then return 1
	else exit 1; fi
}


# TODO: For more informations on Jaro Mail read the manual: man jaro

main()
    {
    local -A subcommands_opts
    ### Options configuration
    #Hi, dear developer! Are you trying to add a new subcommand, or to add some options?
    #Well, keep in mind that:
    # 1. An option CAN'T have differente meanings/behaviour in different subcommands.
    #    For example, "-s" means "size" and accept an argument. If you are tempted to add
    #    an option "-s" (that means, for example "silent", and doesn't accept an argument)
    #              DON'T DO IT!
    #     There are two reasons for that:
    #       I. usability; user expect that "-s" is "size
    #       II. Option parsing WILL EXPLODE if you do this kind of bad things
    #               (it will say "option defined more than once, and he's right)
    main_opts=(a: -account=a l: -list=l q -quiet=q D -debug=D h -help=h v -version=v n -dry-run=n)
    subcommands_opts[__default]=""
    subcommands_opts[queue]=""
    subcommands_opts[fetch]=""
    subcommands_opts[send]=""
    subcommands_opts[peek]=""
    subcommands_opts[update]=""

    subcommands_opts[stat]=""

    subcommands_opts[search]=""
    subcommands_opts[addr]=""
    subcommands_opts[query]=""
    subcommands_opts[learn]=""
    subcommands_opts[forget]=""
    subcommands_opts[list]=""

    subcommands_opts[edit]=""
    subcommands_opts[open]=""

    subcommands_opts[backup]=""
    subcommands_opts[rmdupes]=""
    subcommands_opts[merge]=""
    subcommands_opts[filter]=""

    subcommands_opts[passwd]=""
    subcommands_opts[cert]=""

    subcommands_opts[ramdisk]=""
    subcommands_opts[source]=""

#    subcommands_opts[mount]=${subcommands_opts[open]}
#    subcommands_opts[create]="s: -size=s -ignore-swap k: -key=k"
    ### Detect subcommand
    local -aU every_opts #every_opts behave like a set; that is, an array with unique elements
    for optspec in $subcommands_opts$main_opts; do
	for opt in ${=optspec}; do
	    every_opts+=${opt}
	done
    done
    local -a oldstar
    oldstar=($argv)
    zparseopts -M -E -D -Adiscardme ${every_opts}
    unset discardme
    subcommand=$1
    if [[ -z $subcommand ]]; then
	subcommand="__default"
    fi

# QUAA
    if [[ -z ${(k)subcommands_opts[$subcommand]} ]]; then
 # unknown command, pass it to autostart
	func "unknown command, autostart: $@"
	autostart ${=@}
	exitcode=$?
	{ test $exitcode != 0 } && {
		error "command \"$subcommand\" not recognized"
		act "try -h for help"
		CLEANEXIT=0
	}
    	return $exitcode
    fi

    argv=(${oldstar})
    unset oldstar

    ### Parsing global + command-specific options
    # zsh magic: ${=string} will split to multiple arguments when spaces occur
    set -A cmd_opts ${main_opts} ${=subcommands_opts[$subcommand]}
    if [[ -n $cmd_opts ]]; then #if there is no option, we don't need parsing
	zparseopts -M -E -D -Aopts ${cmd_opts}
	if [[ $? != 0 ]]; then
	    error "Some error occurred during option processing."
	    exitcode=1
	    return 1
	fi
    fi
  #build PARAM (array of arguments) and check if there are unrecognized options
    local ok=0
    for arg in $*; do
	if [[ $arg == '--' || $arg == '-' ]]; then
	    ok=1
	    continue #it shouldnt be appended to PARAM
	elif [[ $arg[1] == '-'  ]]; then
	    if [[ $ok == 0 ]]; then
		error "unrecognized option $arg"
		exitcode=1
		return 1
	    fi
	fi
	PARAM+=$arg
    done
  #first parameter actually is the subcommand: delete it and shift
    if [[ $subcommand != '__default' ]]; then
	PARAM[1]=()
	shift
    fi
  ### End parsing command-specific options

    if option_is_set -v; then
	cat $JAROMAILEXEC | awk '/^#/ {print $0 } !/^#/ {exit}'
	echo
    fi
    if option_is_set -a; then account=`option_value -a`; fi
    if option_is_set -l; then list=`option_value -l`; fi
    { option_is_set -h } && { CLEANEXIT=0; usage; return 0 }
    { option_is_set -v } && { CLEANEXIT=0;
	cat $JAROMAILEXEC | awk 'BEGIN { v=1 } !/^#/ { exit }'; return 0 }
    if option_is_set -q; then QUIET=1; fi
    if option_is_set -D; then func "Debug messages ON"; DEBUG=1; fi
    if option_is_set -n; then act "Dry run, show operations without executing them."; DRYRUN=1; fi

    case "$subcommand" in
	queue)   queue ${PARAM} ;;
	fetch)   fetch ${PARAM} ;;
	send)    send ${PARAM} ;;
	peek)    peek ${PARAM} ;;

	update)  update ;;

	search)  CLEANEXIT=0; search ${PARAM} ;;

	stat)   CLEANEXIT=0; stats ${PARAM} ;;

	addr)    CLEANEXIT=0; address ${PARAM} ;;
	query)   CLEANEXIT=0; query ${PARAM} ;;
	learn)   CLEANEXIT=0; learn ${PARAM} ;;
	forget)  CLEANEXIT=0; forget ${PARAM} ;;
	list)    CLEANEXIT=0; list_addresses ${PARAM} ;;

	edit)    CLEANEXIT=0; editor ${PARAM} ;;
	open)    CLEANEXIT=0; open_file ${PARAM} ;;

	backup)  backup ${PARAM} ;;
	rmdupes) rmdupes ${PARAM} ;;
	merge)   merge ${PARAM} ;;
	filter)  filter ${PARAM} ;;

	passwd)  read_account;
	    { test $? = 0 } && { new_password ${PARAM} }
	    ;;
	cert)    cert ${PARAM} ;;

	ramdisk) ramdisk ${PARAM} ;;

	'source')   CLEANEXIT=0; return 0 ;;
	__default)  func "no command provided"
	    autostart ${PARAM}
	    exitcode=$?
	    ;;
	*) # unknown command, pass it to autostart
	    func "unknown command, remote check"
	    autostart ${PARAM}
	    exitcode=$?
	    { $exitcode != 0 } && {
		error "command \"$subcommand\" not recognized"
		act "try -h for help"
		CLEANEXIT=0
	    }
	    ;;
    esac
    return 0
}

check_bin
main $@
if [ $CLEANEXIT = 1 ]; then cleanexit; fi
return $exitcode
